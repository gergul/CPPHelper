#pragma once
#include "Base.h"
#include "ComHelper.h"
#include <setupapi.h>
#include <ntstatus.h>
#pragma comment(lib,"setupapi.lib")

#pragma warning(push)
#pragma warning(disable: 28251)

#ifdef ENABLE_BACKUP_RESTORE
	#if ENABLE_BACKUP_RESTORE >=2
	extern DWORD REG_OPTION = 0;
	#endif
#endif

//过滤指定字符
LPCWSTR StrFilter(LPCWSTR SrcStr, LPCWSTR IgnoreStr)
{
	while (StrChrW(IgnoreStr, *SrcStr))
	{
		SrcStr++;
	}

	return SrcStr;
}


//获取指定字符串
bool StrGet(LPCWSTR &_Str, LPCWSTR EndStr, LPCWSTR ErrorStr, CString&data)
{
	data = L"";
	for (LPCWSTR Str = _Str; *Str&& StrChrW(ErrorStr, *Str) == NULL; Str++)
	{
		if (StrChrW(EndStr, *Str) == NULL)
		{
			data += *Str;
		}
		else
		{
			_Str = Str;
			return true;
		}
	}

	return false;
}



LPCWSTR StrExistI(LPCWSTR Str, LPCWSTR Find)
{
	if (Str && Find)
	{
		while (*Str)
		{
			if (StrCmpIW(Str, Find))
			{
				Str = StrSpet(Str);
			}
			else
			{
				return Str;
			}
		}
	}

	return NULL;
}



void AppendBstr(BSTR& Str, LPCWSTR Append)
{
	DWORD cchAppend = wcslen(Append) + 1;
	int cchStr = 0;
	if (Str == 0)
	{
		cchStr = 1;
		Str = SysAllocStringLen(NULL, cchAppend + 1);
	}
	else
	{
		cchStr = SysStringLen(Str);
		SysReAllocStringLen(&Str, Str,cchStr + cchAppend);
		//SysFreeString(Str);
		//Str = TempStr;
	}
	cchStr--;
	memcpy(Str + cchStr, Append, (size_t)cchAppend << 1);

	Str[cchStr + cchAppend] = NULL;
}


size_t StrRemove(LPWSTR RemoveStr)
{
	LPWSTR Next = StrSpet(RemoveStr);

	auto cch = Next - RemoveStr;

	for (; *Next;)
	{
		do
		{
			*(RemoveStr++) = *Next;

		} while (*(Next++));
	}

	*RemoveStr = NULL;

	return cch;
}


CString StrFormat(_In_z_ _Printf_format_string_ LPCWSTR Format, ...)
{
	va_list argList;
	va_start(argList, Format);

	CString T;

	T.FormatV(Format, argList);

	va_end(argList);

	return T;
}


void StrDelete(CString& Scr, LPCWSTR Dst)
{
	int cchDst = StrLen(Dst);

	int i = 0;

	while ((i = Scr.Find(Dst, i)) != -1)
	{
		i += cchDst;

		while (i<Scr.GetLength() && StrCmpN(Scr.GetBuffer() + i, Dst, cchDst) == 0)
		{
			Scr.Delete(i, cchDst);
		}
	}
}

CString Str2MultiStr(LPCWSTR Str)
{
	CString MultiStr;

	for (; *Str; Str++)
	{
		if (*Str == L'\r')
		{
			//continue;
		}
		else if (*Str == L'\n')
		{
			if (MultiStr.GetLength() && MultiStr[MultiStr.GetLength() - 1])
			{
				MultiStr.AppendChar(NULL);
			}
		}
		else
		{
			MultiStr.AppendChar(*Str);
		}
	}

	if (MultiStr.GetLength() && MultiStr[MultiStr.GetLength() - 1])
	{
		MultiStr.AppendChar(NULL);
	}

	//MultiStr.AppendChar(NULL);

	return MultiStr;
}


//将字节数按字符输出
CString StrFormatByte(LONGLONG ByteSize)
{
	WCHAR SizeStr[24];
	return StrFormatByteSize64(ByteSize, SizeStr, 24);
}

CStringA Unicode2UTF8(LPCWSTR Str)
{
	return Unicode2UTF8(Str, StrLen(Str));
}

CStringA Unicode2UTF8(LPCWSTR Str,DWORD cStr)
{
	auto chUtf8Str = WideCharToMultiByte(CP_UTF8, 0, Str, cStr, NULL, 0, NULL, NULL);

	CStringA Utf8Str;

	Utf8Str.ReleaseBufferSetLength(WideCharToMultiByte(CP_UTF8, 0, Str, cStr, Utf8Str.GetBuffer(chUtf8Str), chUtf8Str, NULL, NULL));

	return Utf8Str;
}


BOOL StrRegexMatch(LPCWSTR Str, LPCWSTR MatchStr)
{
	LPCWSTR Next;
	//LPCWSTR MatchStr = *this;
	LPCWSTR _Now = Str;
	int cchNow = StrLen(Str);

	int cchMatch;
	int Flage = 1;

	while (Next = StrChr(MatchStr, L'*'))
	{

		//进行正则*匹配
		cchMatch = Next - MatchStr;

		for (int i = 0; *Str&& i != Flage; i++, Str++)
		{
			if (StrCmpNI(Str, MatchStr, cchMatch) == 0)
			{
				goto St;
			}
		}

		return FALSE;

	St:
		Flage = -1;
		Str += cchMatch;
		MatchStr = Next + 1;
	}

	if (Flage != 1)
	{
		cchMatch = cchNow - (Str - _Now) - StrLen(MatchStr);

		Str = cchMatch >= 0 ? Str + cchMatch : NULL;
	}

	if (Str)
		return StrCmpI(Str, MatchStr) == 0;
	else
		return 0;
}

LPCSTR __HexStr = "0123456789ABCDEF";

CString Binary2String(const byte*pBinaryData, DWORD cbData)
{
	CString Buffer;
	Buffer.GetBuffer(cbData * 2);

	for (BYTE* pTData = (BYTE*)pBinaryData, *End = pTData + cbData; pTData != End; pTData++)
	{
		Buffer += __HexStr[(*pTData) >> 4];
		Buffer += __HexStr[(*pTData) & 0xF];
	}

	return Buffer;
}

CStringA HexString2Binary(LPCWSTR HexString)
{
	CStringA Data;

	for (;*HexString;)
	{
		auto Ch = Char2Hex(*(HexString++)) << 4;

		Data.AppendChar(Ch | Char2Hex(*(HexString++)));
	}

	return Data;
}

CStringA HexString2Binary(LPCSTR HexString)
{
	CStringA Data;

	for (; *HexString;)
	{
		auto Ch = Char2Hex(*(HexString++)) << 4;

		Data.AppendChar(Ch | Char2Hex(*(HexString++)));
	}

	return Data;
}


#include <ntddvol.h>
#include <winioctl.h>

#pragma pack(push,1)
typedef struct {
	UINT8  BootIndicator;
	UINT8  StartHead;
	UINT8  StartSector;
	UINT8  StartTrack;
	UINT8  OSType;
	UINT8  EndHead;
	UINT8  EndSector;
	UINT8  EndTrack;
	UINT32 StartingLBA;
	UINT32 SizeInLBA;
} MBR_PARTITION_RECORD;


typedef struct {
	UINT8                 BootCode[440];
	UINT32                UniqueMbrSignature;
	UINT16                Unknown;
	MBR_PARTITION_RECORD  PartitionRecord[4];
	UINT16                Signature;
} MASTER_BOOT_RECORD;

//Dos2.0
struct PARTITION_BOOT_RECORD_DOS2
{
	byte CodeJmp[3]; //跳转代码
	char OEMName[8]; //分区名称

	WORD SectorBytes;//Bytes per logical sector
	BYTE LogicalSectors;//Logical sectors per cluster
	WORD ReservedLogicalSectors;
	BYTE NumbeOfFATs;	//NTFS
	WORD RootDirectory;
	WORD TotalLogicalSectors;
	BYTE MediaDescriptor;
	WORD LogicalSectorsPerFAT;
};

//DOS 3.31 BPB
struct PARTITION_BOOT_RECORD_DOS3_31 :public PARTITION_BOOT_RECORD_DOS2
{
	WORD PhysicalSectorsPerTrack;
	WORD NumberOfHeads;
	DWORD HiddenSectors;
	DWORD TotalSectors;
};

struct PARTITION_BOOT_RECORD_NTFS :public PARTITION_BOOT_RECORD_DOS3_31
{
	BYTE PhysicalDriveNumber;
	BYTE Flags;
	BYTE ExtendedBootSignature;//0x80
	BYTE Reserved;
	UINT64 VolumeSectors;
	UINT64 MFTFirstClusterNumber;
	UINT64 MFTMirrorFirstClusterNumber;
	DWORD MFTRecordSize;
	DWORD IndexBlockSize;
	UINT64 VolumeSerialNumber;
	DWORD Checksum;
	byte BootCode[0x1E00 + 0x1AC];
};

#pragma pack(pop)

const BYTE NtMbr[] =
{
	0x33, 0xC0, 0x8E, 0xD0, 0xBC, 0x00, 0x7C, 0x8E,
	0xC0, 0x8E, 0xD8, 0xBE, 0x00, 0x7C, 0xBF, 0x00,
	0x06, 0xB9, 0x00, 0x02, 0xFC, 0xF3, 0xA4, 0x50,
	0x68, 0x1C, 0x06, 0xCB, 0xFB, 0xB9, 0x04, 0x00,
	0xBD, 0xBE, 0x07, 0x80, 0x7E, 0x00, 0x00, 0x7C,
	0x0B, 0x0F, 0x85, 0x0E, 0x01, 0x83, 0xC5, 0x10,
	0xE2, 0xF1, 0xCD, 0x18, 0x88, 0x56, 0x00, 0x55,
	0xC6, 0x46, 0x11, 0x05, 0xC6, 0x46, 0x10, 0x00,
	0xB4, 0x41, 0xBB, 0xAA, 0x55, 0xCD, 0x13, 0x5D,
	0x72, 0x0F, 0x81, 0xFB, 0x55, 0xAA, 0x75, 0x09,
	0xF7, 0xC1, 0x01, 0x00, 0x74, 0x03, 0xFE, 0x46,
	0x10, 0x66, 0x60, 0x80, 0x7E, 0x10, 0x00, 0x74,
	0x26, 0x66, 0x68, 0x00, 0x00, 0x00, 0x00, 0x66,
	0xFF, 0x76, 0x08, 0x68, 0x00, 0x00, 0x68, 0x00,
	0x7C, 0x68, 0x01, 0x00, 0x68, 0x10, 0x00, 0xB4,
	0x42, 0x8A, 0x56, 0x00, 0x8B, 0xF4, 0xCD, 0x13,
	0x9F, 0x83, 0xC4, 0x10, 0x9E, 0xEB, 0x14, 0xB8,
	0x01, 0x02, 0xBB, 0x00, 0x7C, 0x8A, 0x56, 0x00,
	0x8A, 0x76, 0x01, 0x8A, 0x4E, 0x02, 0x8A, 0x6E,
	0x03, 0xCD, 0x13, 0x66, 0x61, 0x73, 0x1C, 0xFE,
	0x4E, 0x11, 0x75, 0x0C, 0x80, 0x7E, 0x00, 0x80,
	0x0F, 0x84, 0x8A, 0x00, 0xB2, 0x80, 0xEB, 0x84,
	0x55, 0x32, 0xE4, 0x8A, 0x56, 0x00, 0xCD, 0x13,
	0x5D, 0xEB, 0x9E, 0x81, 0x3E, 0xFE, 0x7D, 0x55,
	0xAA, 0x75, 0x6E, 0xFF, 0x76, 0x00, 0xE8, 0x8D,
	0x00, 0x75, 0x17, 0xFA, 0xB0, 0xD1, 0xE6, 0x64,
	0xE8, 0x83, 0x00, 0xB0, 0xDF, 0xE6, 0x60, 0xE8,
	0x7C, 0x00, 0xB0, 0xFF, 0xE6, 0x64, 0xE8, 0x75,
	0x00, 0xFB, 0xB8, 0x00, 0xBB, 0xCD, 0x1A, 0x66,
	0x23, 0xC0, 0x75, 0x3B, 0x66, 0x81, 0xFB, 0x54,
	0x43, 0x50, 0x41, 0x75, 0x32, 0x81, 0xF9, 0x02,
	0x01, 0x72, 0x2C, 0x66, 0x68, 0x07, 0xBB, 0x00,
	0x00, 0x66, 0x68, 0x00, 0x02, 0x00, 0x00, 0x66,
	0x68, 0x08, 0x00, 0x00, 0x00, 0x66, 0x53, 0x66,
	0x53, 0x66, 0x55, 0x66, 0x68, 0x00, 0x00, 0x00,
	0x00, 0x66, 0x68, 0x00, 0x7C, 0x00, 0x00, 0x66,
	0x61, 0x68, 0x00, 0x00, 0x07, 0xCD, 0x1A, 0x5A,
	0x32, 0xF6, 0xEA, 0x00, 0x7C, 0x00, 0x00, 0xCD,
	0x18, 0xA0, 0xB7, 0x07, 0xEB, 0x08, 0xA0, 0xB6,
	0x07, 0xEB, 0x03, 0xA0, 0xB5, 0x07, 0x32, 0xE4,
	0x05, 0x00, 0x07, 0x8B, 0xF0, 0xAC, 0x3C, 0x00,
	0x74, 0x09, 0xBB, 0x07, 0x00, 0xB4, 0x0E, 0xCD,
	0x10, 0xEB, 0xF2, 0xF4, 0xEB, 0xFD, 0x2B, 0xC9,
	0xE4, 0x64, 0xEB, 0x00, 0x24, 0x02, 0xE0, 0xF8,
	0x24, 0x02, 0xC3, 0x49, 0x6E, 0x76, 0x61, 0x6C,
	0x69, 0x64, 0x20, 0x70, 0x61, 0x72, 0x74, 0x69,
	0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x61, 0x62,
	0x6C, 0x65, 0x00, 0x45, 0x72, 0x72, 0x6F, 0x72,
	0x20, 0x6C, 0x6F, 0x61, 0x64, 0x69, 0x6E, 0x67,
	0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
	0x6E, 0x67, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65,
	0x6D, 0x00, 0x4D, 0x69, 0x73, 0x73, 0x69, 0x6E,
	0x67, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6E, 0x67, 0x20, 0x73, 0x79, 0x73, 0x74,
	0x65, 0x6D, 0x00, 0x00, 0x00, 0x63, 0x7B, 0x9A,
};

const BYTE NTFS_PBR[] =
{
	0xFA ,0x33 ,0xC0 ,0x8E ,0xD0 ,0xBC ,0x00 ,0x7C ,0xFB ,0x68 ,0xC0 ,0x07 ,0x1F ,0x1E ,0x68 ,0x66,
	0x00 ,0xCB ,0x88 ,0x16 ,0x0E ,0x00 ,0x66 ,0x81 ,0x3E ,0x03 ,0x00 ,0x4E ,0x54 ,0x46 ,0x53 ,0x75,
	0x15 ,0xB4 ,0x41 ,0xBB ,0xAA ,0x55 ,0xCD ,0x13 ,0x72 ,0x0C ,0x81 ,0xFB ,0x55 ,0xAA ,0x75 ,0x06,
	0xF7 ,0xC1 ,0x01 ,0x00 ,0x75 ,0x03 ,0xE9 ,0xDD ,0x00 ,0x1E ,0x83 ,0xEC ,0x18 ,0x68 ,0x1A ,0x00,
	0xB4 ,0x48 ,0x8A ,0x16 ,0x0E ,0x00 ,0x8B ,0xF4 ,0x16 ,0x1F ,0xCD ,0x13 ,0x9F ,0x83 ,0xC4 ,0x18,
	0x9E ,0x58 ,0x1F ,0x72 ,0xE1 ,0x3B ,0x06 ,0x0B ,0x00 ,0x75 ,0xDB ,0xA3 ,0x0F ,0x00 ,0xC1 ,0x2E,
	0x0F ,0x00 ,0x04 ,0x1E ,0x5A ,0x33 ,0xDB ,0xB9 ,0x00 ,0x20 ,0x2B ,0xC8 ,0x66 ,0xFF ,0x06 ,0x11,
	0x00 ,0x03 ,0x16 ,0x0F ,0x00 ,0x8E ,0xC2 ,0xFF ,0x06 ,0x16 ,0x00 ,0xE8 ,0x4B ,0x00 ,0x2B ,0xC8,
	0x77 ,0xEF ,0xB8 ,0x00 ,0xBB ,0xCD ,0x1A ,0x66 ,0x23 ,0xC0 ,0x75 ,0x2D ,0x66 ,0x81 ,0xFB ,0x54,
	0x43 ,0x50 ,0x41 ,0x75 ,0x24 ,0x81 ,0xF9 ,0x02 ,0x01 ,0x72 ,0x1E ,0x16 ,0x68 ,0x07 ,0xBB ,0x16,
	0x68 ,0x52 ,0x11 ,0x16 ,0x68 ,0x09 ,0x00 ,0x66 ,0x53 ,0x66 ,0x53 ,0x66 ,0x55 ,0x16 ,0x16 ,0x16,
	0x68 ,0xB8 ,0x01 ,0x66 ,0x61 ,0x0E ,0x07 ,0xCD ,0x1A ,0x33 ,0xC0 ,0xBF ,0x0A ,0x13 ,0xB9 ,0xF6,
	0x0C ,0xFC ,0xF3 ,0xAA ,0xE9 ,0xFE ,0x01 ,0x90 ,0x90 ,0x66 ,0x60 ,0x1E ,0x06 ,0x66 ,0xA1 ,0x11,
	0x00 ,0x66 ,0x03 ,0x06 ,0x1C ,0x00 ,0x1E ,0x66 ,0x68 ,0x00 ,0x00 ,0x00 ,0x00 ,0x66 ,0x50 ,0x06,
	0x53 ,0x68 ,0x01 ,0x00 ,0x68 ,0x10 ,0x00 ,0xB4 ,0x42 ,0x8A ,0x16 ,0x0E ,0x00 ,0x16 ,0x1F ,0x8B,
	0xF4 ,0xCD ,0x13 ,0x66 ,0x59 ,0x5B ,0x5A ,0x66 ,0x59 ,0x66 ,0x59 ,0x1F ,0x0F ,0x82 ,0x16 ,0x00,
	0x66 ,0xFF ,0x06 ,0x11 ,0x00 ,0x03 ,0x16 ,0x0F ,0x00 ,0x8E ,0xC2 ,0xFF ,0x0E ,0x16 ,0x00 ,0x75,
	0xBC ,0x07 ,0x1F ,0x66 ,0x61 ,0xC3 ,0xA1 ,0xF6 ,0x01 ,0xE8 ,0x09 ,0x00 ,0xA1 ,0xFA ,0x01 ,0xE8,
	0x03 ,0x00 ,0xF4 ,0xEB ,0xFD ,0x8B ,0xF0 ,0xAC ,0x3C ,0x00 ,0x74 ,0x09 ,0xB4 ,0x0E ,0xBB ,0x07,
	0x00 ,0xCD ,0x10 ,0xEB ,0xF2 ,0xC3 ,0x0D ,0x0A ,0x41 ,0x20 ,0x64 ,0x69 ,0x73 ,0x6B ,0x20 ,0x72,
	0x65 ,0x61 ,0x64 ,0x20 ,0x65 ,0x72 ,0x72 ,0x6F ,0x72 ,0x20 ,0x6F ,0x63 ,0x63 ,0x75 ,0x72 ,0x72,
	0x65 ,0x64 ,0x00 ,0x0D ,0x0A ,0x42 ,0x4F ,0x4F ,0x54 ,0x4D ,0x47 ,0x52 ,0x20 ,0x69 ,0x73 ,0x20,
	0x63 ,0x6F ,0x6D ,0x70 ,0x72 ,0x65 ,0x73 ,0x73 ,0x65 ,0x64 ,0x00 ,0x0D ,0x0A ,0x50 ,0x72 ,0x65,
	0x73 ,0x73 ,0x20 ,0x43 ,0x74 ,0x72 ,0x6C ,0x2B ,0x41 ,0x6C ,0x74 ,0x2B ,0x44 ,0x65 ,0x6C ,0x20,
	0x74 ,0x6F ,0x20 ,0x72 ,0x65 ,0x73 ,0x74 ,0x61 ,0x72 ,0x74 ,0x0D ,0x0A ,0x00 ,0x00 ,0x00 ,0x00,
	0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00,
	0x00 ,0x00 ,0x8A ,0x01 ,0xA7 ,0x01 ,0xBF ,0x01 ,0x00 ,0x00 ,0x55 ,0xAA ,0x07 ,0x00 ,0x42 ,0x00,
	0x4F ,0x00 ,0x4F ,0x00 ,0x54 ,0x00 ,0x4D ,0x00 ,0x47 ,0x00 ,0x52 ,0x00 ,0x04 ,0x00 ,0x24 ,0x00,
	0x49 ,0x00 ,0x33 ,0x00 ,0x30 ,0x00 ,0x00 ,0xD4 ,0x00 ,0x00 ,0x00 ,0x24 ,0x00 ,0x00 ,0x00 ,0x00,
	0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00,
	0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00,
	0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00,
	0x00 ,0x00 ,0xE9 ,0xC0 ,0x00 ,0x90 ,0x05 ,0x00 ,0x4E ,0x00 ,0x54 ,0x00 ,0x4C ,0x00 ,0x44 ,0x00,
	0x52 ,0x00 ,0x07 ,0x00 ,0x42 ,0x00 ,0x4F ,0x00 ,0x4F ,0x00 ,0x54 ,0x00 ,0x54 ,0x00 ,0x47 ,0x00,
	0x54 ,0x00 ,0x07 ,0x00 ,0x42 ,0x00 ,0x4F ,0x00 ,0x4F ,0x00 ,0x54 ,0x00 ,0x4E ,0x00 ,0x58 ,0x00,
	0x54 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00,
	0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0D ,0x0A ,0x41 ,0x6E ,0x20 ,0x6F ,0x70 ,0x65 ,0x72 ,0x61,
	0x74 ,0x69 ,0x6E ,0x67 ,0x20 ,0x73 ,0x79 ,0x73 ,0x74 ,0x65 ,0x6D ,0x20 ,0x77 ,0x61 ,0x73 ,0x6E,
	0x27 ,0x74 ,0x20 ,0x66 ,0x6F ,0x75 ,0x6E ,0x64 ,0x2E ,0x20 ,0x54 ,0x72 ,0x79 ,0x20 ,0x64 ,0x69,
	0x73 ,0x63 ,0x6F ,0x6E ,0x6E ,0x65 ,0x63 ,0x74 ,0x69 ,0x6E ,0x67 ,0x20 ,0x61 ,0x6E ,0x79 ,0x20,
	0x64 ,0x72 ,0x69 ,0x76 ,0x65 ,0x73 ,0x20 ,0x74 ,0x68 ,0x61 ,0x74 ,0x20 ,0x64 ,0x6F ,0x6E ,0x27,
	0x74 ,0x0D ,0x0A ,0x63 ,0x6F ,0x6E ,0x74 ,0x61 ,0x69 ,0x6E ,0x20 ,0x61 ,0x6E ,0x20 ,0x6F ,0x70,
	0x65 ,0x72 ,0x61 ,0x74 ,0x69 ,0x6E ,0x67 ,0x20 ,0x73 ,0x79 ,0x73 ,0x74 ,0x65 ,0x6D ,0x2E ,0x00,
	0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00,
	0x00 ,0x00 ,0x00 ,0x9A ,0x02 ,0x66 ,0x0F ,0xB7 ,0x06 ,0x0B ,0x00 ,0x66 ,0x0F ,0xB6 ,0x1E ,0x0D,
	0x00 ,0x66 ,0xF7 ,0xE3 ,0x66 ,0xA3 ,0x52 ,0x02 ,0x66 ,0x8B ,0x0E ,0x40 ,0x00 ,0x80 ,0xF9 ,0x00,
	0x0F ,0x8F ,0x0E ,0x00 ,0xF6 ,0xD9 ,0x66 ,0xB8 ,0x01 ,0x00 ,0x00 ,0x00 ,0x66 ,0xD3 ,0xE0 ,0xEB,
	0x08 ,0x90 ,0x66 ,0xA1 ,0x52 ,0x02 ,0x66 ,0xF7 ,0xE1 ,0x66 ,0xA3 ,0x86 ,0x02 ,0x66 ,0x0F ,0xB7,
	0x1E ,0x0B ,0x00 ,0x66 ,0x33 ,0xD2 ,0x66 ,0xF7 ,0xF3 ,0x66 ,0xA3 ,0x56 ,0x02 ,0xE8 ,0xA2 ,0x04,
	0x66 ,0x8B ,0x0E ,0x4E ,0x02 ,0x66 ,0x89 ,0x0E ,0x26 ,0x02 ,0x66 ,0x03 ,0x0E ,0x86 ,0x02 ,0x66,
	0x89 ,0x0E ,0x2A ,0x02 ,0x66 ,0x03 ,0x0E ,0x86 ,0x02 ,0x66 ,0x89 ,0x0E ,0x2E ,0x02 ,0x66 ,0x03,
	0x0E ,0x86 ,0x02 ,0x66 ,0x89 ,0x0E ,0x3E ,0x02 ,0x66 ,0x03 ,0x0E ,0x86 ,0x02 ,0x66 ,0x89 ,0x0E,
	0x46 ,0x02 ,0x66 ,0xB8 ,0x90 ,0x00 ,0x00 ,0x00 ,0x66 ,0x8B ,0x0E ,0x26 ,0x02 ,0xE8 ,0x90 ,0x09,
	0x66 ,0x0B ,0xC0 ,0x0F ,0x84 ,0xBF ,0xFD ,0x66 ,0xA3 ,0x32 ,0x02 ,0x66 ,0xB8 ,0xA0 ,0x00 ,0x00,
	0x00 ,0x66 ,0x8B ,0x0E ,0x2A ,0x02 ,0xE8 ,0x77 ,0x09 ,0x66 ,0xA3 ,0x36 ,0x02 ,0x66 ,0xB8 ,0xB0,
	0x00 ,0x00 ,0x00 ,0x66 ,0x8B ,0x0E ,0x2E ,0x02 ,0xE8 ,0x65 ,0x09 ,0x66 ,0xA3 ,0x3A ,0x02 ,0x66,
	0xA1 ,0x32 ,0x02 ,0x66 ,0x0B ,0xC0 ,0x0F ,0x84 ,0x8C ,0xFD ,0x67 ,0x80 ,0x78 ,0x08 ,0x00 ,0x0F,
	0x85 ,0x83 ,0xFD ,0x67 ,0x66 ,0x8D ,0x50 ,0x10 ,0x67 ,0x03 ,0x42 ,0x04 ,0x67 ,0x66 ,0x0F ,0xB6,
	0x48 ,0x0C ,0x66 ,0x89 ,0x0E ,0x92 ,0x02 ,0x67 ,0x66 ,0x8B ,0x48 ,0x08 ,0x66 ,0x89 ,0x0E ,0x8E,
	0x02 ,0x66 ,0xA1 ,0x8E ,0x02 ,0x66 ,0x0F ,0xB7 ,0x0E ,0x0B ,0x00 ,0x66 ,0x33 ,0xD2 ,0x66 ,0xF7,
	0xF1 ,0x66 ,0xA3 ,0x96 ,0x02 ,0x66 ,0xA1 ,0x46 ,0x02 ,0x66 ,0x03 ,0x06 ,0x8E ,0x02 ,0x66 ,0xA3,
	0x4A ,0x02 ,0x66 ,0x83 ,0x3E ,0x36 ,0x02 ,0x00 ,0x0F ,0x84 ,0x1D ,0x00 ,0x66 ,0x83 ,0x3E ,0x3A,
	0x02 ,0x00 ,0x0F ,0x84 ,0x30 ,0xFD ,0x66 ,0x8B ,0x1E ,0x3A ,0x02 ,0x1E ,0x07 ,0x66 ,0x8B ,0x3E,
	0x4A ,0x02 ,0x66 ,0xA1 ,0x2E ,0x02 ,0xE8 ,0xED ,0x01 ,0xE8 ,0x2C ,0x0D ,0x66 ,0x0B ,0xC0 ,0x0F,
	0x84 ,0x03 ,0x00 ,0xE8 ,0x42 ,0x0E ,0x66 ,0x0F ,0xB7 ,0x0E ,0x00 ,0x02 ,0x66 ,0xB8 ,0x02 ,0x02,
	0x00 ,0x00 ,0xE8 ,0x22 ,0x08 ,0x66 ,0x0B ,0xC0 ,0x0F ,0x85 ,0x16 ,0x00 ,0x66 ,0x0F ,0xB7 ,0x0E,
	0x5A ,0x02 ,0x66 ,0xB8 ,0x5C ,0x02 ,0x00 ,0x00 ,0xE8 ,0x0C ,0x08 ,0x66 ,0x0B ,0xC0 ,0x0F ,0x84,
	0x78 ,0x0E ,0x67 ,0x66 ,0x8B ,0x00 ,0x1E ,0x07 ,0x66 ,0x8B ,0x3E ,0x3E ,0x02 ,0xE8 ,0x3F ,0x06,
	0x66 ,0xA1 ,0x3E ,0x02 ,0x66 ,0xBB ,0x20 ,0x00 ,0x00 ,0x00 ,0x66 ,0xB9 ,0x00 ,0x00 ,0x00 ,0x00,
	0x66 ,0xBA ,0x00 ,0x00 ,0x00 ,0x00 ,0xE8 ,0xE4 ,0x00 ,0x66 ,0x85 ,0xC0 ,0x0F ,0x85 ,0x23 ,0x00,
	0x66 ,0xA1 ,0x3E ,0x02 ,0x66 ,0xBB ,0x80 ,0x00 ,0x00 ,0x00 ,0x66 ,0xB9 ,0x00 ,0x00 ,0x00 ,0x00,
	0x66 ,0xBA ,0x00 ,0x00 ,0x00 ,0x00 ,0xE8 ,0xC4 ,0x00 ,0x66 ,0x0B ,0xC0 ,0x0F ,0x85 ,0x44 ,0x00,
	0xE9 ,0x27 ,0x0E ,0x66 ,0x33 ,0xD2 ,0x66 ,0xB9 ,0x80 ,0x00 ,0x00 ,0x00 ,0x66 ,0xA1 ,0x3E ,0x02,
	0xE8 ,0xCA ,0x08 ,0x66 ,0x0B ,0xC0 ,0x0F ,0x84 ,0x10 ,0x0E ,0x1E ,0x07 ,0x66 ,0x8B ,0x3E ,0x3E,
	0x02 ,0xE8 ,0xDB ,0x05 ,0x66 ,0xA1 ,0x3E ,0x02 ,0x66 ,0xBB ,0x80 ,0x00 ,0x00 ,0x00 ,0x66 ,0xB9,
	0x00 ,0x00 ,0x00 ,0x00 ,0x66 ,0xBA ,0x00 ,0x00 ,0x00 ,0x00 ,0xE8 ,0x80 ,0x00 ,0x66 ,0x0B ,0xC0,
	0x0F ,0x84 ,0xE6 ,0x0D ,0x67 ,0x66 ,0x0F ,0xB7 ,0x58 ,0x0C ,0x66 ,0x81 ,0xE3 ,0xFF ,0x00 ,0x00,
	0x00 ,0x0F ,0x85 ,0xDB ,0x0D ,0x66 ,0x8B ,0xD8 ,0x68 ,0x00 ,0x20 ,0x07 ,0x66 ,0x2B ,0xFF ,0x66,
	0xA1 ,0x3E ,0x02 ,0xE8 ,0x00 ,0x01 ,0x68 ,0x00 ,0x20 ,0x07 ,0x66 ,0x2B ,0xFF ,0x66 ,0xA1 ,0x3E,
	0x02 ,0xE8 ,0xAC ,0x0A ,0x8A ,0x16 ,0x0E ,0x00 ,0xB8 ,0xE8 ,0x03 ,0x8E ,0xC0 ,0x8D ,0x36 ,0x0B,
	0x00 ,0x2B ,0xC0 ,0x68 ,0x00 ,0x20 ,0x50 ,0xCB ,0x06 ,0x1E ,0x66 ,0x60 ,0x66 ,0x8B ,0xDA ,0x66,
	0x0F ,0xB6 ,0x0E ,0x0D ,0x00 ,0x66 ,0xF7 ,0xE1 ,0x66 ,0xA3 ,0x11 ,0x00 ,0x66 ,0x8B ,0xC3 ,0x66,
	0xF7 ,0xE1 ,0xA3 ,0x16 ,0x00 ,0x8B ,0xDF ,0x83 ,0xE3 ,0x0F ,0x8C ,0xC0 ,0x66 ,0xC1 ,0xEF ,0x04,
	0x03 ,0xC7 ,0x50 ,0x07 ,0xE8 ,0x92 ,0xFB ,0x66 ,0x61 ,0x90 ,0x1F ,0x07 ,0xC3 ,0x67 ,0x03 ,0x40,
	0x14 ,0x67 ,0x66 ,0x83 ,0x38 ,0xFF ,0x0F ,0x84 ,0x4C ,0x00 ,0x67 ,0x66 ,0x39 ,0x18 ,0x0F ,0x85,
	0x33 ,0x00 ,0x66 ,0x0B ,0xC9 ,0x0F ,0x85 ,0x0A ,0x00 ,0x67 ,0x80 ,0x78 ,0x09 ,0x00 ,0x0F ,0x85,
	0x23 ,0x00 ,0xC3 ,0x67 ,0x3A ,0x48 ,0x09 ,0x0F ,0x85 ,0x1A ,0x00 ,0x66 ,0x8B ,0xF0 ,0x67 ,0x03,
	0x70 ,0x0A ,0xE8 ,0x97 ,0x06 ,0x66 ,0x51 ,0x1E ,0x07 ,0x66 ,0x8B ,0xFA ,0xF3 ,0xA7 ,0x66 ,0x59,
	0x0F ,0x85 ,0x01 ,0x00 ,0xC3 ,0x67 ,0x66 ,0x83 ,0x78 ,0x04 ,0x00 ,0x0F ,0x84 ,0x07 ,0x00 ,0x67,
	0x66 ,0x03 ,0x40 ,0x04 ,0xEB ,0xAB ,0x66 ,0x2B ,0xC0 ,0xC3 ,0x66 ,0x8B ,0xF3 ,0xE8 ,0x6C ,0x06,
	0x67 ,0x66 ,0x03 ,0x00 ,0x67 ,0xF7 ,0x40 ,0x0C ,0x02 ,0x00 ,0x0F ,0x85 ,0x34 ,0x00 ,0x67 ,0x66,
	0x8D ,0x50 ,0x10 ,0x67 ,0x3A ,0x4A ,0x40 ,0x0F ,0x85 ,0x18 ,0x00 ,0x67 ,0x66 ,0x8D ,0x72 ,0x42,
	0xE8 ,0x49 ,0x06 ,0x66 ,0x51 ,0x1E ,0x07 ,0x66 ,0x8B ,0xFB ,0xF3 ,0xA7 ,0x66 ,0x59 ,0x0F ,0x85,
	0x01 ,0x00 ,0xC3 ,0x67 ,0x83 ,0x78 ,0x08 ,0x00 ,0x0F ,0x84 ,0x06 ,0x00 ,0x67 ,0x03 ,0x40 ,0x08,
	0xEB ,0xC2 ,0x66 ,0x33 ,0xC0 ,0xC3 ,0x67 ,0x80 ,0x7B ,0x08 ,0x00 ,0x0F ,0x85 ,0x1C ,0x00 ,0x06,
	0x1E ,0x66 ,0x60 ,0x67 ,0x66 ,0x8D ,0x53 ,0x10 ,0x67 ,0x66 ,0x8B ,0x0A ,0x66 ,0x8B ,0xF3 ,0x67,
	0x03 ,0x72 ,0x04 ,0xF3 ,0xA4 ,0x66 ,0x61 ,0x90 ,0x1F ,0x07 ,0xC3 ,0x66 ,0x50 ,0x67 ,0x66 ,0x8D,
	0x53 ,0x10 ,0x66 ,0x85 ,0xC0 ,0x0F ,0x85 ,0x0A ,0x00 ,0x67 ,0x66 ,0x8B ,0x4A ,0x08 ,0x66 ,0x41,
	0xEB ,0x11 ,0x90 ,0x67 ,0x66 ,0x8B ,0x42 ,0x18 ,0x66 ,0x33 ,0xD2 ,0x66 ,0xF7 ,0x36 ,0x52 ,0x02,
	0x66 ,0x8B ,0xC8 ,0x66 ,0x2B ,0xC0 ,0x66 ,0x5E ,0xE8 ,0x01 ,0x00 ,0xC3 ,0x06 ,0x1E ,0x66 ,0x60,
	0x67 ,0x80 ,0x7B ,0x08 ,0x01 ,0x0F ,0x84 ,0x03 ,0x00 ,0xE9 ,0xCA ,0xFA ,0x66 ,0x83 ,0xF9 ,0x00,
	0x0F ,0x85 ,0x06 ,0x00 ,0x66 ,0x61 ,0x90 ,0x1F ,0x07 ,0xC3 ,0x66 ,0x53 ,0x66 ,0x50 ,0x66 ,0x51,
	0x66 ,0x56 ,0x66 ,0x57 ,0x06 ,0xE8 ,0x91 ,0x04 ,0x66 ,0x8B ,0xD1 ,0x07 ,0x66 ,0x5F ,0x66 ,0x5E,
	0x66 ,0x59 ,0x66 ,0x85 ,0xC0 ,0x0F ,0x84 ,0x34 ,0x00 ,0x66 ,0x3B ,0xCA ,0x0F ,0x8D ,0x03 ,0x00,
	0x66 ,0x8B ,0xD1 ,0xE8 ,0x82 ,0xFE ,0x66 ,0x2B ,0xCA ,0x66 ,0x8B ,0xDA ,0x66 ,0x8B ,0xC2 ,0x66,
	0x0F ,0xB6 ,0x16 ,0x0D ,0x00 ,0x66 ,0xF7 ,0xE2 ,0x66 ,0x0F ,0xB7 ,0x16 ,0x0B ,0x00 ,0x66 ,0xF7,
	0xE2 ,0x66 ,0x03 ,0xF8 ,0x66 ,0x58 ,0x66 ,0x03 ,0xC3 ,0x66 ,0x5B ,0xEB ,0x9F ,0x66 ,0x85 ,0xF6,
	0x0F ,0x84 ,0x62 ,0xFA ,0x66 ,0x51 ,0x66 ,0x57 ,0x06 ,0x67 ,0x66 ,0x0F ,0xB6 ,0x43 ,0x09 ,0x66,
	0x85 ,0xC0 ,0x0F ,0x84 ,0x20 ,0x00 ,0x66 ,0xD1 ,0xE0 ,0x66 ,0x2B ,0xE0 ,0x66 ,0x8B ,0xFC ,0x66,
	0x54 ,0x66 ,0x56 ,0x67 ,0x66 ,0x0F ,0xB7 ,0x73 ,0x0A ,0x66 ,0x03 ,0xF3 ,0x66 ,0x8B ,0xC8 ,0xF3,
	0xA4 ,0x66 ,0x5E ,0xEB ,0x03 ,0x90 ,0x66 ,0x50 ,0x66 ,0x50 ,0x67 ,0x66 ,0x8B ,0x03 ,0x66 ,0x50,
	0x67 ,0x66 ,0x8B ,0x43 ,0x18 ,0x66 ,0x50 ,0x67 ,0x66 ,0x8B ,0x56 ,0x20 ,0x66 ,0x85 ,0xD2 ,0x0F,
	0x84 ,0x0B ,0x00 ,0x66 ,0x8B ,0xFE ,0x1E ,0x07 ,0x66 ,0x8B ,0xC2 ,0xE8 ,0x71 ,0x03 ,0x66 ,0x8B,
	0xC6 ,0x66 ,0x5A ,0x66 ,0x59 ,0x66 ,0x42 ,0x66 ,0x51 ,0x66 ,0x56 ,0xE8 ,0x3F ,0x06 ,0x66 ,0x85,
	0xC0 ,0x0F ,0x84 ,0xF1 ,0xF9 ,0x66 ,0x5E ,0x66 ,0x59 ,0x66 ,0x8B ,0xFE ,0x1E ,0x07 ,0xE8 ,0x4E,
	0x03 ,0x66 ,0x8B ,0xC6 ,0x66 ,0x8B ,0xD9 ,0x66 ,0x59 ,0x66 ,0x5A ,0x66 ,0x51 ,0x66 ,0x56 ,0x66,
	0xD1 ,0xE9 ,0xE8 ,0xF8 ,0xFD ,0x66 ,0x85 ,0xC0 ,0x0F ,0x84 ,0xCA ,0xF9 ,0x66 ,0x5E ,0x66 ,0x59,
	0x66 ,0x03 ,0xE1 ,0x07 ,0x66 ,0x5F ,0x66 ,0x59 ,0x66 ,0x8B ,0xD0 ,0x66 ,0x58 ,0x66 ,0x5B ,0x66,
	0x8B ,0xDA ,0xE9 ,0xF5 ,0xFE ,0x06 ,0x1E ,0x66 ,0x60 ,0x26 ,0x67 ,0x66 ,0x0F ,0xB7 ,0x5F ,0x04,
	0x26 ,0x67 ,0x66 ,0x0F ,0xB7 ,0x4F ,0x06 ,0x66 ,0x0B ,0xC9 ,0x0F ,0x84 ,0x98 ,0xF9 ,0x66 ,0x03,
	0xDF ,0x66 ,0x83 ,0xC3 ,0x02 ,0x66 ,0x81 ,0xC7 ,0xFE ,0x01 ,0x00 ,0x00 ,0x66 ,0x49 ,0x66 ,0x0B,
	0xC9 ,0x0F ,0x84 ,0x17 ,0x00 ,0x26 ,0x67 ,0x8B ,0x03 ,0x26 ,0x67 ,0x89 ,0x07 ,0x66 ,0x83 ,0xC3,
	0x02 ,0x66 ,0x81 ,0xC7 ,0x00 ,0x02 ,0x00 ,0x00 ,0x66 ,0x49 ,0xEB ,0xE2 ,0x66 ,0x61 ,0x90 ,0x1F,
	0x07 ,0xC3 ,0x06 ,0x1E ,0x66 ,0x60 ,0x66 ,0xB8 ,0x01 ,0x00 ,0x00 ,0x00 ,0x66 ,0xA3 ,0x22 ,0x02,
	0x66 ,0xA1 ,0x1E ,0x02 ,0x66 ,0x03 ,0x06 ,0x86 ,0x02 ,0x66 ,0xA3 ,0x8A ,0x02 ,0x66 ,0x03 ,0x06,
	0x86 ,0x02 ,0x66 ,0xA3 ,0x4E ,0x02 ,0x66 ,0xA1 ,0x30 ,0x00 ,0x66 ,0x0F ,0xB6 ,0x1E ,0x0D ,0x00,
	0x66 ,0xF7 ,0xE3 ,0x66 ,0x8B ,0x1E ,0x4E ,0x02 ,0x66 ,0x89 ,0x07 ,0x66 ,0xA3 ,0x11 ,0x00 ,0x83,
	0xC3 ,0x04 ,0x66 ,0xA1 ,0x56 ,0x02 ,0x66 ,0x89 ,0x07 ,0xA3 ,0x16 ,0x00 ,0x83 ,0xC3 ,0x04 ,0x66,
	0x89 ,0x1E ,0x4E ,0x02 ,0x66 ,0x8B ,0x1E ,0x1E ,0x02 ,0x1E ,0x07 ,0xE8 ,0xBB ,0xF8 ,0x66 ,0x8B,
	0xFB ,0xE8 ,0x51 ,0xFF ,0x66 ,0xA1 ,0x1E ,0x02 ,0x66 ,0xBB ,0x20 ,0x00 ,0x00 ,0x00 ,0x66 ,0xB9,
	0x00 ,0x00 ,0x00 ,0x00 ,0x66 ,0xBA ,0x00 ,0x00 ,0x00 ,0x00 ,0xE8 ,0x10 ,0xFD ,0x66 ,0x0B ,0xC0,
	0x0F ,0x84 ,0x19 ,0x01 ,0x66 ,0x8B ,0xD8 ,0x1E ,0x07 ,0x66 ,0x8B ,0x3E ,0x1A ,0x02 ,0x66 ,0x33,
	0xC0 ,0xE8 ,0xA2 ,0xFD ,0x66 ,0x8B ,0x1E ,0x1A ,0x02 ,0x66 ,0x81 ,0x3F ,0x80 ,0x00 ,0x00 ,0x00,
	0x0F ,0x84 ,0xEB ,0x00 ,0x03 ,0x5F ,0x04 ,0xEB ,0xF0 ,0x66 ,0x53 ,0x66 ,0x8B ,0x47 ,0x10 ,0x66,
	0xF7 ,0x26 ,0x56 ,0x02 ,0x66 ,0x50 ,0x66 ,0x33 ,0xD2 ,0x66 ,0x0F ,0xB6 ,0x1E ,0x0D ,0x00 ,0x66,
	0xF7 ,0xF3 ,0x66 ,0x52 ,0xE8 ,0xDC ,0x00 ,0x66 ,0x0B ,0xC0 ,0x0F ,0x84 ,0x98 ,0xF8 ,0x66 ,0x8B,
	0x0E ,0x56 ,0x02 ,0x66 ,0x0F ,0xB6 ,0x1E ,0x0D ,0x00 ,0x66 ,0xF7 ,0xE3 ,0x66 ,0x5A ,0x66 ,0x03,
	0xC2 ,0x66 ,0x8B ,0x1E ,0x4E ,0x02 ,0x66 ,0x89 ,0x07 ,0x83 ,0xC3 ,0x04 ,0x66 ,0x0F ,0xB6 ,0x06,
	0x0D ,0x00 ,0x66 ,0x2B ,0xC2 ,0x66 ,0x3B ,0xC1 ,0x0F ,0x86 ,0x03 ,0x00 ,0x66 ,0x8B ,0xC1 ,0x66,
	0x89 ,0x07 ,0x66 ,0x2B ,0xC8 ,0x66 ,0x5A ,0x0F ,0x84 ,0x75 ,0x00 ,0x66 ,0x03 ,0xC2 ,0x66 ,0x50,
	0x66 ,0x33 ,0xD2 ,0x66 ,0x0F ,0xB6 ,0x1E ,0x0D ,0x00 ,0x66 ,0xF7 ,0xF3 ,0x66 ,0x51 ,0xE8 ,0x82,
	0x00 ,0x66 ,0x59 ,0x66 ,0x0B ,0xC0 ,0x0F ,0x84 ,0x3C ,0xF8 ,0x66 ,0x0F ,0xB6 ,0x1E ,0x0D ,0x00,
	0x66 ,0xF7 ,0xE3 ,0x66 ,0x8B ,0x1E ,0x4E ,0x02 ,0x66 ,0x8B ,0x17 ,0x83 ,0xC3 ,0x04 ,0x66 ,0x03,
	0x17 ,0x66 ,0x3B ,0xD0 ,0x0F ,0x85 ,0x15 ,0x00 ,0x66 ,0x0F ,0xB6 ,0x06 ,0x0D ,0x00 ,0x66 ,0x3B,
	0xC1 ,0x0F ,0x86 ,0x03 ,0x00 ,0x66 ,0x8B ,0xC1 ,0x66 ,0x01 ,0x07 ,0xEB ,0xA5 ,0x83 ,0xC3 ,0x04,
	0x66 ,0x89 ,0x1E ,0x4E ,0x02 ,0x66 ,0x89 ,0x07 ,0x83 ,0xC3 ,0x04 ,0x66 ,0x0F ,0xB6 ,0x06 ,0x0D,
	0x00 ,0x66 ,0x3B ,0xC1 ,0x0F ,0x86 ,0x03 ,0x00 ,0x66 ,0x8B ,0xC1 ,0x66 ,0x89 ,0x07 ,0xEB ,0x82,
	0x83 ,0xC3 ,0x04 ,0x66 ,0xFF ,0x06 ,0x22 ,0x02 ,0x66 ,0x89 ,0x1E ,0x4E ,0x02 ,0x66 ,0x5B ,0x03,
	0x5F ,0x04 ,0x66 ,0x81 ,0x3F ,0x80 ,0x00 ,0x00 ,0x00 ,0x0F ,0x84 ,0x0C ,0xFF ,0x66 ,0x61 ,0x90,
	0x1F ,0x07 ,0xC3 ,0x66 ,0x8B ,0xD0 ,0x66 ,0x8B ,0x0E ,0x22 ,0x02 ,0x66 ,0x8B ,0x36 ,0x8A ,0x02,
	0x66 ,0x03 ,0x36 ,0x86 ,0x02 ,0x66 ,0x52 ,0x66 ,0x51 ,0x66 ,0x52 ,0x66 ,0x8B ,0x1E ,0x8A ,0x02,
	0x66 ,0x8B ,0x3E ,0x56 ,0x02 ,0x66 ,0x8B ,0x04 ,0x66 ,0xA3 ,0x11 ,0x00 ,0x83 ,0xC6 ,0x04 ,0x66,
	0x8B ,0x04 ,0xA3 ,0x16 ,0x00 ,0x83 ,0xC6 ,0x04 ,0x1E ,0x07 ,0xE8 ,0x3C ,0xF7 ,0x66 ,0x2B ,0xF8,
	0x0F ,0x84 ,0x08 ,0x00 ,0xF7 ,0x26 ,0x0B ,0x00 ,0x03 ,0xD8 ,0xEB ,0xD9 ,0x66 ,0x8B ,0x3E ,0x8A,
	0x02 ,0x1E ,0x07 ,0xE8 ,0xBF ,0xFD ,0x66 ,0xA1 ,0x8A ,0x02 ,0x66 ,0xBB ,0x80 ,0x00 ,0x00 ,0x00,
	0x66 ,0xB9 ,0x00 ,0x00 ,0x00 ,0x00 ,0x66 ,0x8B ,0xD1 ,0xE8 ,0x81 ,0xFB ,0x66 ,0x0B ,0xC0 ,0x0F,
	0x84 ,0x53 ,0xF7 ,0x66 ,0x8B ,0xD8 ,0x66 ,0x58 ,0x66 ,0x56 ,0xE8 ,0x2C ,0x01 ,0x66 ,0x5E ,0x66,
	0x0B ,0xC0 ,0x0F ,0x84 ,0x05 ,0x00 ,0x66 ,0x5B ,0x66 ,0x5B ,0xC3 ,0x66 ,0x59 ,0x66 ,0x5A ,0xE2,
	0x84 ,0x66 ,0x33 ,0xC0 ,0xC3 ,0x06 ,0x1E ,0x66 ,0x60 ,0x66 ,0x50 ,0x66 ,0x51 ,0x66 ,0x33 ,0xD2,
	0x66 ,0x0F ,0xB6 ,0x1E ,0x0D ,0x00 ,0x66 ,0xF7 ,0xF3 ,0x66 ,0x52 ,0x66 ,0x57 ,0xE8 ,0x53 ,0xFF,
	0x66 ,0x5F ,0x66 ,0x0B ,0xC0 ,0x0F ,0x84 ,0x0D ,0xF7 ,0x66 ,0x0F ,0xB6 ,0x1E ,0x0D ,0x00 ,0x66,
	0xF7 ,0xE3 ,0x66 ,0x5A ,0x66 ,0x03 ,0xC2 ,0x66 ,0xA3 ,0x11 ,0x00 ,0x66 ,0x59 ,0x66 ,0x0F ,0xB6,
	0x1E ,0x0D ,0x00 ,0x66 ,0x3B ,0xCB ,0x0F ,0x8E ,0x13 ,0x00 ,0x89 ,0x1E ,0x16 ,0x00 ,0x66 ,0x2B,
	0xCB ,0x66 ,0x58 ,0x66 ,0x03 ,0xC3 ,0x66 ,0x50 ,0x66 ,0x51 ,0xEB ,0x14 ,0x90 ,0x66 ,0x58 ,0x66,
	0x03 ,0xC1 ,0x66 ,0x50 ,0x89 ,0x0E ,0x16 ,0x00 ,0x66 ,0xB9 ,0x00 ,0x00 ,0x00 ,0x00 ,0x66 ,0x51,
	0x06 ,0x66 ,0x57 ,0x8B ,0xDF ,0x83 ,0xE3 ,0x0F ,0x8C ,0xC0 ,0x66 ,0xC1 ,0xEF ,0x04 ,0x03 ,0xC7,
	0x50 ,0x07 ,0xE8 ,0x64 ,0xF6 ,0x66 ,0x5F ,0x07 ,0x66 ,0x03 ,0x3E ,0x52 ,0x02 ,0x66 ,0x59 ,0x66,
	0x58 ,0x66 ,0x83 ,0xF9 ,0x00 ,0x0F ,0x8F ,0x70 ,0xFF ,0x66 ,0x61 ,0x90 ,0x1F ,0x07 ,0xC3 ,0x06,
	0x1E ,0x66 ,0x60 ,0x66 ,0xF7 ,0x26 ,0x56 ,0x02 ,0x66 ,0x8B ,0x0E ,0x56 ,0x02 ,0xE8 ,0x55 ,0xFF,
	0xE8 ,0xD2 ,0xFC ,0x66 ,0x61 ,0x90 ,0x1F ,0x07 ,0xC3 ,0x06 ,0x1E ,0x66 ,0x60 ,0x66 ,0xF7 ,0x26,
	0x92 ,0x02 ,0x66 ,0x8B ,0x1E ,0x36 ,0x02 ,0x66 ,0x8B ,0x0E ,0x92 ,0x02 ,0x66 ,0x8B ,0x36 ,0x2A,
	0x02 ,0x1E ,0x07 ,0x66 ,0x8B ,0x3E ,0x46 ,0x02 ,0xE8 ,0x81 ,0xFB ,0xE8 ,0xA7 ,0xFC ,0x66 ,0x61,
	0x90 ,0x1F ,0x07 ,0xC3 ,0x66 ,0x50 ,0x66 ,0x53 ,0x66 ,0x51 ,0x66 ,0x8B ,0x1E ,0x4A ,0x02 ,0x66,
	0x8B ,0xC8 ,0x66 ,0xC1 ,0xE8 ,0x03 ,0x66 ,0x83 ,0xE1 ,0x07 ,0x66 ,0x03 ,0xD8 ,0x66 ,0xB8 ,0x01,
	0x00 ,0x00 ,0x00 ,0x66 ,0xD3 ,0xE0 ,0x67 ,0x84 ,0x03 ,0x0F ,0x84 ,0x04 ,0x00 ,0xF8 ,0xEB ,0x02,
	0x90 ,0xF9 ,0x66 ,0x59 ,0x66 ,0x5B ,0x66 ,0x58 ,0xC3 ,0x67 ,0x80 ,0x7B ,0x08 ,0x01 ,0x0F ,0x84,
	0x04 ,0x00 ,0x66 ,0x2B ,0xC0 ,0xC3 ,0x67 ,0x66 ,0x8D ,0x73 ,0x10 ,0x67 ,0x66 ,0x8B ,0x56 ,0x08,
	0x66 ,0x3B ,0xC2 ,0x0F ,0x87 ,0x0B ,0x00 ,0x67 ,0x66 ,0x8B ,0x16 ,0x66 ,0x3B ,0xC2 ,0x0F ,0x83,
	0x04 ,0x00 ,0x66 ,0x2B ,0xC0 ,0xC3 ,0x67 ,0x03 ,0x5E ,0x10 ,0x66 ,0x2B ,0xF6 ,0x67 ,0x80 ,0x3B,
	0x00 ,0x0F ,0x84 ,0x3E ,0x00 ,0xE8 ,0x81 ,0x00 ,0x66 ,0x03 ,0xF1 ,0xE8 ,0x39 ,0x00 ,0x66 ,0x03,
	0xCA ,0x66 ,0x3B ,0xC1 ,0x0F ,0x8C ,0x21 ,0x00 ,0x66 ,0x8B ,0xD1 ,0x66 ,0x50 ,0x67 ,0x66 ,0x0F,
	0xB6 ,0x0B ,0x66 ,0x8B ,0xC1 ,0x66 ,0x83 ,0xE0 ,0x0F ,0x66 ,0xC1 ,0xE9 ,0x04 ,0x66 ,0x03 ,0xD9,
	0x66 ,0x03 ,0xD8 ,0x66 ,0x43 ,0x66 ,0x58 ,0xEB ,0xC4 ,0x66 ,0x2B ,0xC8 ,0x66 ,0x2B ,0xC2 ,0x66,
	0x03 ,0xC6 ,0xC3 ,0x66 ,0x2B ,0xC0 ,0xC3 ,0x66 ,0x2B ,0xC9 ,0x67 ,0x8A ,0x0B ,0x80 ,0xE1 ,0x0F,
	0x66 ,0x83 ,0xF9 ,0x00 ,0x0F ,0x85 ,0x04 ,0x00 ,0x66 ,0x2B ,0xC9 ,0xC3 ,0x66 ,0x53 ,0x66 ,0x52,
	0x66 ,0x03 ,0xD9 ,0x67 ,0x66 ,0x0F ,0xBE ,0x13 ,0x66 ,0x49 ,0x66 ,0x4B ,0x66 ,0x83 ,0xF9 ,0x00,
	0x0F ,0x84 ,0x0D ,0x00 ,0x66 ,0xC1 ,0xE2 ,0x08 ,0x67 ,0x8A ,0x13 ,0x66 ,0x4B ,0x66 ,0x49 ,0xEB,
	0xEB ,0x66 ,0x8B ,0xCA ,0x66 ,0x5A ,0x66 ,0x5B ,0xC3 ,0x66 ,0x53 ,0x66 ,0x52 ,0x66 ,0x2B ,0xD2,
	0x67 ,0x8A ,0x13 ,0x66 ,0x83 ,0xE2 ,0x0F ,0x66 ,0x2B ,0xC9 ,0x67 ,0x8A ,0x0B ,0xC0 ,0xE9 ,0x04,
	0x66 ,0x83 ,0xF9 ,0x00 ,0x0F ,0x85 ,0x08 ,0x00 ,0x66 ,0x2B ,0xC9 ,0x66 ,0x5A ,0x66 ,0x5B ,0xC3,
	0x66 ,0x03 ,0xDA ,0x66 ,0x03 ,0xD9 ,0x67 ,0x66 ,0x0F ,0xBE ,0x13 ,0x66 ,0x49 ,0x66 ,0x4B ,0x66,
	0x83 ,0xF9 ,0x00 ,0x0F ,0x84 ,0x0D ,0x00 ,0x66 ,0xC1 ,0xE2 ,0x08 ,0x67 ,0x8A ,0x13 ,0x66 ,0x4B,
	0x66 ,0x49 ,0xEB ,0xEB ,0x66 ,0x8B ,0xCA ,0x66 ,0x5A ,0x66 ,0x5B ,0xC3 ,0x66 ,0x0B ,0xC9 ,0x0F,
	0x85 ,0x01 ,0x00 ,0xC3 ,0x66 ,0x51 ,0x66 ,0x56 ,0x67 ,0x83 ,0x3E ,0x61 ,0x0F ,0x8C ,0x0C ,0x00,
	0x67 ,0x83 ,0x3E ,0x7A ,0x0F ,0x8F ,0x04 ,0x00 ,0x67 ,0x83 ,0x2E ,0x20 ,0x66 ,0x83 ,0xC6 ,0x02,
	0xE2 ,0xE6 ,0x66 ,0x5E ,0x66 ,0x59 ,0xC3 ,0x66 ,0x50 ,0x66 ,0x51 ,0x66 ,0x8B ,0xD0 ,0x66 ,0xA1,
	0x32 ,0x02 ,0x67 ,0x66 ,0x8D ,0x58 ,0x10 ,0x67 ,0x03 ,0x43 ,0x04 ,0x67 ,0x66 ,0x8D ,0x40 ,0x10,
	0x66 ,0x8B ,0xDA ,0xE8 ,0x44 ,0xF9 ,0x66 ,0x0B ,0xC0 ,0x0F ,0x84 ,0x05 ,0x00 ,0x66 ,0x59 ,0x66,
	0x59 ,0xC3 ,0x66 ,0xA1 ,0x36 ,0x02 ,0x66 ,0x0B ,0xC0 ,0x0F ,0x85 ,0x08 ,0x00 ,0x66 ,0x59 ,0x66,
	0x59 ,0x66 ,0x33 ,0xC0 ,0xC3 ,0x66 ,0x8B ,0x16 ,0x36 ,0x02 ,0x67 ,0x66 ,0x8D ,0x52 ,0x10 ,0x67,
	0x66 ,0x8B ,0x42 ,0x18 ,0x66 ,0x33 ,0xD2 ,0x66 ,0xF7 ,0x36 ,0x8E ,0x02 ,0x66 ,0x33 ,0xF6 ,0x66,
	0x50 ,0x66 ,0x56 ,0x66 ,0x58 ,0x66 ,0x5E ,0x66 ,0x3B ,0xC6 ,0x0F ,0x84 ,0x3A ,0x00 ,0x66 ,0x56,
	0x66 ,0x40 ,0x66 ,0x50 ,0x66 ,0x48 ,0xE8 ,0x1B ,0xFE ,0x72 ,0xE8 ,0xE8 ,0xEB ,0xFD ,0x66 ,0x5A,
	0x66 ,0x5E ,0x66 ,0x59 ,0x66 ,0x5B ,0x66 ,0x53 ,0x66 ,0x51 ,0x66 ,0x56 ,0x66 ,0x52 ,0x66 ,0xA1,
	0x46 ,0x02 ,0x67 ,0x66 ,0x8D ,0x40 ,0x18 ,0xE8 ,0xD0 ,0xF8 ,0x66 ,0x0B ,0xC0 ,0x74 ,0xC4 ,0x66,
	0x59 ,0x66 ,0x59 ,0x66 ,0x59 ,0x66 ,0x59 ,0xC3 ,0x66 ,0x59 ,0x66 ,0x59 ,0x66 ,0x33 ,0xC0 ,0xC3,
	0x66 ,0x51 ,0x66 ,0x50 ,0x66 ,0xB8 ,0x05 ,0x00 ,0x00 ,0x00 ,0x1E ,0x07 ,0x66 ,0x8B ,0xF9 ,0xE8,
	0x8D ,0xFD ,0x66 ,0x8B ,0xC1 ,0x66 ,0xBB ,0x20 ,0x00 ,0x00 ,0x00 ,0x66 ,0xB9 ,0x00 ,0x00 ,0x00,
	0x00 ,0x66 ,0xBA ,0x00 ,0x00 ,0x00 ,0x00 ,0xE8 ,0x33 ,0xF8 ,0x66 ,0x5B ,0x66 ,0x59 ,0x66 ,0x85,
	0xC0 ,0x0F ,0x85 ,0x15 ,0x00 ,0x66 ,0x8B ,0xC1 ,0x66 ,0x0F ,0xB7 ,0x0E ,0x10 ,0x02 ,0x66 ,0xBA,
	0x12 ,0x02 ,0x00 ,0x00 ,0xE8 ,0x16 ,0xF8 ,0xEB ,0x33 ,0x90 ,0x66 ,0x33 ,0xD2 ,0x66 ,0x8B ,0xC1,
	0x66 ,0x8B ,0xCB ,0x66 ,0x50 ,0x66 ,0x53 ,0xE8 ,0x23 ,0x00 ,0x66 ,0x5B ,0x66 ,0x5F ,0x66 ,0x0B,
	0xC0 ,0x0F ,0x84 ,0x17 ,0x00 ,0x1E ,0x07 ,0xE8 ,0x35 ,0xFD ,0x66 ,0x8B ,0xC7 ,0x66 ,0x0F ,0xB7,
	0x0E ,0x10 ,0x02 ,0x66 ,0xBA ,0x12 ,0x02 ,0x00 ,0x00 ,0xE8 ,0xE1 ,0xF7 ,0xC3 ,0x66 ,0x52 ,0x66,
	0x51 ,0x66 ,0xBB ,0x20 ,0x00 ,0x00 ,0x00 ,0x66 ,0xB9 ,0x00 ,0x00 ,0x00 ,0x00 ,0x66 ,0xBA ,0x00,
	0x00 ,0x00 ,0x00 ,0xE8 ,0xC7 ,0xF7 ,0x66 ,0x0B ,0xC0 ,0x0F ,0x84 ,0x63 ,0x00 ,0x66 ,0x8B ,0xD8,
	0x1E ,0x07 ,0x66 ,0x8B ,0x3E ,0x1A ,0x02 ,0x66 ,0x33 ,0xC0 ,0xE8 ,0x59 ,0xF8 ,0x1E ,0x07 ,0x66,
	0x8B ,0x1E ,0x1A ,0x02 ,0x66 ,0x59 ,0x66 ,0x5A ,0x26 ,0x66 ,0x39 ,0x0F ,0x0F ,0x85 ,0x0C ,0x00,
	0x26 ,0x66 ,0x39 ,0x57 ,0x08 ,0x0F ,0x84 ,0x31 ,0x00 ,0xEB ,0x13 ,0x90 ,0x26 ,0x66 ,0x83 ,0x3F,
	0xFF ,0x0F ,0x84 ,0x2F ,0x00 ,0x26 ,0x83 ,0x7F ,0x04 ,0x00 ,0x0F ,0x84 ,0x26 ,0x00 ,0x26 ,0x66,
	0x0F ,0xB7 ,0x47 ,0x04 ,0x03 ,0xD8 ,0x8B ,0xC3 ,0x25 ,0x00 ,0x80 ,0x74 ,0xCB ,0x8C ,0xC0 ,0x05,
	0x00 ,0x08 ,0x8E ,0xC0 ,0x81 ,0xE3 ,0xFF ,0x7F ,0xEB ,0xBE ,0x26 ,0x66 ,0x8B ,0x47 ,0x10 ,0xC3,
	0x66 ,0x59 ,0x66 ,0x5A ,0x66 ,0x33 ,0xC0 ,0xC3 ,0x66 ,0x50 ,0x66 ,0x51 ,0x66 ,0x8B ,0xC7 ,0x66,
	0xC1 ,0xE8 ,0x04 ,0x06 ,0x59 ,0x03 ,0xC8 ,0x51 ,0x07 ,0x66 ,0x83 ,0xE7 ,0x0F ,0x66 ,0x59 ,0x66,
	0x58 ,0xC3 ,0x60 ,0x06 ,0xBE ,0x69 ,0x0E ,0xBF ,0x00 ,0x20 ,0x1E ,0x07 ,0xB9 ,0x0D ,0x00 ,0x90,
	0xF3 ,0xA5 ,0x07 ,0x61 ,0xC3 ,0x01 ,0x23 ,0x45 ,0x67 ,0x89 ,0xAB ,0xCD ,0xEF ,0xFE ,0xDC ,0xBA,
	0x98 ,0x76 ,0x54 ,0x32 ,0x10 ,0xF0 ,0xE1 ,0xD2 ,0xC3 ,0x00 ,0x00 ,0x00 ,0x00 ,0x20 ,0x20 ,0x60,
	0x8B ,0x36 ,0x18 ,0x20 ,0x26 ,0x8A ,0x05 ,0x88 ,0x04 ,0x47 ,0x46 ,0x66 ,0xFF ,0x06 ,0x14 ,0x20,
	0x81 ,0xFE ,0x60 ,0x20 ,0x75 ,0x06 ,0xE8 ,0x5B ,0x00 ,0xBE ,0x20 ,0x20 ,0xE2 ,0xE6 ,0x89 ,0x36,
	0x18 ,0x20 ,0x61 ,0xC3 ,0x66 ,0x60 ,0x8B ,0x36 ,0x18 ,0x20 ,0xB0 ,0x80 ,0x88 ,0x04 ,0x46 ,0x32,
	0xC0 ,0x81 ,0xFE ,0x60 ,0x20 ,0x75 ,0x06 ,0xE8 ,0x3A ,0x00 ,0xBE ,0x20 ,0x20 ,0x81 ,0xFE ,0x58,
	0x20 ,0x75 ,0xE9 ,0x66 ,0x33 ,0xC0 ,0x66 ,0xA3 ,0x58 ,0x20 ,0x66 ,0xA1 ,0x14 ,0x20 ,0x66 ,0xC1,
	0xE0 ,0x03 ,0x66 ,0x0F ,0xC8 ,0x66 ,0xA3 ,0x5C ,0x20 ,0xE8 ,0x18 ,0x00 ,0xBB ,0x00 ,0x20 ,0x66,
	0x8B ,0x07 ,0x66 ,0x0F ,0xC8 ,0x66 ,0x89 ,0x07 ,0x83 ,0xC3 ,0x04 ,0x81 ,0xFB ,0x34 ,0x20 ,0x75,
	0xEE ,0x66 ,0x61 ,0xC3 ,0x66 ,0x60 ,0xBB ,0x20 ,0x20 ,0x66 ,0x8B ,0x07 ,0x66 ,0x0F ,0xC8 ,0x66,
	0x89 ,0x07 ,0x83 ,0xC3 ,0x04 ,0x81 ,0xFB ,0x60 ,0x20 ,0x75 ,0xEE ,0xBB ,0x00 ,0x20 ,0x66 ,0x8B,
	0x0F ,0x66 ,0x8B ,0x57 ,0x04 ,0x66 ,0x8B ,0x77 ,0x08 ,0x66 ,0x8B ,0x7F ,0x0C ,0x66 ,0x8B ,0x6F,
	0x10 ,0xBB ,0x20 ,0x20 ,0xC7 ,0x06 ,0x1A ,0x20 ,0xDC ,0x0F ,0xC6 ,0x06 ,0x1C ,0x20 ,0x14 ,0x90,
	0x53 ,0x8B ,0x1E ,0x1A ,0x20 ,0xFF ,0x17 ,0x66 ,0x03 ,0x47 ,0x02 ,0x5B ,0x66 ,0x03 ,0xE8 ,0x66,
	0x03 ,0x2F ,0x66 ,0x8B ,0xC1 ,0x66 ,0xC1 ,0xC0 ,0x05 ,0x66 ,0x03 ,0xC5 ,0x66 ,0x8B ,0xEF ,0x66,
	0x8B ,0xFE ,0x66 ,0x8B ,0xF2 ,0x66 ,0xC1 ,0xC6 ,0x1E ,0x66 ,0x8B ,0xD1 ,0x66 ,0x8B ,0xC8 ,0x66,
	0x8B ,0x07 ,0x66 ,0x33 ,0x47 ,0x08 ,0x66 ,0x33 ,0x47 ,0x20 ,0x66 ,0x33 ,0x47 ,0x34 ,0x66 ,0xD1,
	0xC0 ,0x66 ,0x89 ,0x47 ,0x40 ,0x83 ,0xC3 ,0x04 ,0xFE ,0x0E ,0x1C ,0x20 ,0x75 ,0xB2 ,0x83 ,0x06,
	0x1A ,0x20 ,0x06 ,0x81 ,0x3E ,0x1A ,0x20 ,0xF4 ,0x0F ,0x75 ,0x9F ,0xBB ,0x00 ,0x20 ,0x66 ,0x01,
	0x0F ,0x66 ,0x01 ,0x57 ,0x04 ,0x66 ,0x01 ,0x77 ,0x08 ,0x66 ,0x01 ,0x7F ,0x0C ,0x66 ,0x01 ,0x6F,
	0x10 ,0x66 ,0x61 ,0xC3 ,0x66 ,0x8B ,0xC6 ,0x66 ,0x33 ,0xC7 ,0x66 ,0x23 ,0xC2 ,0x66 ,0x33 ,0xC7,
	0xC3 ,0x66 ,0x8B ,0xC2 ,0x66 ,0x33 ,0xC6 ,0x66 ,0x33 ,0xC7 ,0xC3 ,0x66 ,0x53 ,0x66 ,0x8B ,0xC2,
	0x66 ,0x23 ,0xC6 ,0x66 ,0x8B ,0xDA ,0x66 ,0x23 ,0xDF ,0x66 ,0x0B ,0xC3 ,0x66 ,0x8B ,0xDE ,0x66,
	0x23 ,0xDF ,0x66 ,0x0B ,0xC3 ,0x66 ,0x5B ,0xC3 ,0xA8 ,0x0F ,0x99 ,0x79 ,0x82 ,0x5A ,0xB5 ,0x0F,
	0xA1 ,0xEB ,0xD9 ,0x6E ,0xBF ,0x0F ,0xDC ,0xBC ,0x1B ,0x8F ,0xB5 ,0x0F ,0xD6 ,0xC1 ,0x62 ,0xCA,
	0x06 ,0x1E ,0x66 ,0x60 ,0x66 ,0x33 ,0xDB ,0xB8 ,0x00 ,0xBB ,0xCD ,0x1A ,0x66 ,0x23 ,0xC0 ,0x0F,
	0x85 ,0xBB ,0x00 ,0x66 ,0x81 ,0xFB ,0x54 ,0x43 ,0x50 ,0x41 ,0x0F ,0x85 ,0xB0 ,0x00 ,0x81 ,0xF9,
	0x02 ,0x01 ,0x0F ,0x82 ,0xA8 ,0x00 ,0x66 ,0x61 ,0x90 ,0x1F ,0x07 ,0x06 ,0x1E ,0x66 ,0x60 ,0x67,
	0x80 ,0x7B ,0x08 ,0x00 ,0x0F ,0x85 ,0x0C ,0x00 ,0x67 ,0x66 ,0x8D ,0x53 ,0x10 ,0x67 ,0x66 ,0x8B,
	0x0A ,0xEB ,0x25 ,0x90 ,0x67 ,0x66 ,0x8D ,0x53 ,0x10 ,0x67 ,0x66 ,0x8B ,0x4A ,0x28 ,0x66 ,0x81,
	0xF9 ,0x00 ,0x00 ,0x08 ,0x00 ,0x0F ,0x83 ,0x0C ,0x00 ,0x67 ,0x66 ,0x8B ,0x42 ,0x2C ,0x66 ,0x23,
	0xC0 ,0x0F ,0x84 ,0x03 ,0x00 ,0x66 ,0x33 ,0xC9 ,0x0E ,0x1F ,0xE8 ,0xF5 ,0xFD ,0x66 ,0x23 ,0xC9,
	0x0F ,0x84 ,0x32 ,0x00 ,0x66 ,0xBA ,0x00 ,0x80 ,0x00 ,0x00 ,0x66 ,0x3B ,0xCA ,0x0F ,0x86 ,0x1F,
	0x00 ,0x66 ,0x2B ,0xCA ,0x06 ,0x66 ,0x51 ,0x66 ,0x57 ,0x66 ,0x52 ,0x66 ,0x8B ,0xCA ,0xE8 ,0xB7,
	0xFD ,0xE8 ,0xFB ,0xFD ,0x66 ,0x5A ,0x66 ,0x5F ,0x66 ,0x59 ,0x07 ,0x66 ,0x03 ,0xFA ,0xEB ,0xDA,
	0xE8 ,0xA5 ,0xFD ,0xE8 ,0xE9 ,0xFD ,0xE8 ,0x0B ,0xFE ,0x0E ,0x07 ,0x66 ,0xBB ,0x54 ,0x43 ,0x50,
	0x41 ,0x66 ,0xBF ,0x00 ,0x20 ,0x00 ,0x00 ,0x66 ,0xB9 ,0x14 ,0x00 ,0x00 ,0x00 ,0x66 ,0xB8 ,0x07,
	0xBB ,0x00 ,0x00 ,0x66 ,0xBA ,0x0A ,0x00 ,0x00 ,0x00 ,0x66 ,0x33 ,0xF6 ,0xCD ,0x1A ,0x66 ,0x61,
	0x90 ,0x1F ,0x07 ,0xC3 ,0x06 ,0x1E ,0x66 ,0x60 ,0x66 ,0x33 ,0xDB ,0xB8 ,0x00 ,0xBB ,0xCD ,0x1A,
	0x66 ,0x23 ,0xC0 ,0x0F ,0x85 ,0x74 ,0x00 ,0x66 ,0x81 ,0xFB ,0x54 ,0x43 ,0x50 ,0x41 ,0x0F ,0x85,
	0x69 ,0x00 ,0x81 ,0xF9 ,0x02 ,0x01 ,0x0F ,0x82 ,0x61 ,0x00 ,0x66 ,0xB8 ,0x07 ,0xBB ,0x00 ,0x00,
	0x66 ,0xBB ,0x54 ,0x43 ,0x50 ,0x41 ,0x66 ,0xB9 ,0xB8 ,0x01 ,0x00 ,0x00 ,0x66 ,0xBA ,0x04 ,0x00,
	0x00 ,0x00 ,0x66 ,0x33 ,0xF6 ,0x66 ,0xBE ,0x4D ,0x42 ,0x52 ,0x43 ,0x68 ,0x00 ,0x00 ,0x07 ,0x66,
	0xBF ,0x00 ,0x7C ,0x00 ,0x00 ,0xCD ,0x1A ,0x66 ,0xB8 ,0x07 ,0xBB ,0x00 ,0x00 ,0x66 ,0xBB ,0x54,
	0x43 ,0x50 ,0x41 ,0x66 ,0xB9 ,0x42 ,0x00 ,0x00 ,0x00 ,0x66 ,0xBA ,0x05 ,0x00 ,0x00 ,0x00 ,0x66,
	0x33 ,0xF6 ,0x66 ,0xBE ,0x4D ,0x42 ,0x52 ,0x44 ,0x68 ,0x00 ,0x00 ,0x07 ,0x66 ,0xBF ,0x00 ,0x7C,
	0x00 ,0x00 ,0x66 ,0x81 ,0xC7 ,0xBE ,0x01 ,0x00 ,0x00 ,0xCD ,0x1A ,0x66 ,0x61 ,0x90 ,0x1F ,0x07,
	0xC3 ,0x66 ,0x52 ,0x66 ,0x33 ,0xC0 ,0x67 ,0x80 ,0x7B ,0x08 ,0x00 ,0x0F ,0x85 ,0x0C ,0x00 ,0x67,
	0x66 ,0x8D ,0x53 ,0x10 ,0x67 ,0x66 ,0x8B ,0x02 ,0xEB ,0x0B ,0x90 ,0x67 ,0x66 ,0x8D ,0x53 ,0x10,
	0x67 ,0x66 ,0x8B ,0x42 ,0x28 ,0x66 ,0x5A ,0xC3 ,0x06 ,0x1E ,0x66 ,0x60 ,0x66 ,0x0F ,0xB7 ,0x0E,
	0x66 ,0x02 ,0x66 ,0xB8 ,0x68 ,0x02 ,0x00 ,0x00 ,0xE8 ,0xFC ,0xFA ,0x66 ,0x0B ,0xC0 ,0x0F ,0x84,
	0xFA ,0x00 ,0x66 ,0x0F ,0xB7 ,0x0E ,0x76 ,0x02 ,0x66 ,0xB8 ,0x78 ,0x02 ,0x00 ,0x00 ,0xE8 ,0xE6,
	0xFA ,0x66 ,0x0B ,0xC0 ,0x0F ,0x84 ,0xE4 ,0x00 ,0x67 ,0x66 ,0x8B ,0x00 ,0x1E ,0x07 ,0x66 ,0x8B,
	0x3E ,0x3E ,0x02 ,0xE8 ,0x19 ,0xF9 ,0x66 ,0xA1 ,0x3E ,0x02 ,0x66 ,0xBB ,0x20 ,0x00 ,0x00 ,0x00,
	0x66 ,0xB9 ,0x00 ,0x00 ,0x00 ,0x00 ,0x66 ,0xBA ,0x00 ,0x00 ,0x00 ,0x00 ,0xE8 ,0xBE ,0xF3 ,0x66,
	0x85 ,0xC0 ,0x0F ,0x85 ,0x23 ,0x00 ,0x66 ,0xA1 ,0x3E ,0x02 ,0x66 ,0xBB ,0x80 ,0x00 ,0x00 ,0x00,
	0x66 ,0xB9 ,0x00 ,0x00 ,0x00 ,0x00 ,0x66 ,0xBA ,0x00 ,0x00 ,0x00 ,0x00 ,0xE8 ,0x9E ,0xF3 ,0x66,
	0x0B ,0xC0 ,0x0F ,0x85 ,0x44 ,0x00 ,0xE9 ,0x93 ,0x00 ,0x66 ,0x33 ,0xD2 ,0x66 ,0xB9 ,0x80 ,0x00,
	0x00 ,0x00 ,0x66 ,0xA1 ,0x3E ,0x02 ,0xE8 ,0xA4 ,0xFB ,0x66 ,0x0B ,0xC0 ,0x0F ,0x84 ,0x7C ,0x00,
	0x1E ,0x07 ,0x66 ,0x8B ,0x3E ,0x3E ,0x02 ,0xE8 ,0xB5 ,0xF8 ,0x66 ,0xA1 ,0x3E ,0x02 ,0x66 ,0xBB,
	0x80 ,0x00 ,0x00 ,0x00 ,0x66 ,0xB9 ,0x00 ,0x00 ,0x00 ,0x00 ,0x66 ,0xBA ,0x00 ,0x00 ,0x00 ,0x00,
	0xE8 ,0x5A ,0xF3 ,0x66 ,0x0B ,0xC0 ,0x0F ,0x84 ,0x52 ,0x00 ,0x66 ,0x8B ,0xD0 ,0x66 ,0x8B ,0xD8,
	0xE8 ,0x0E ,0xFF ,0x66 ,0x3D ,0x00 ,0x04 ,0x00 ,0x00 ,0x0F ,0x87 ,0x3F ,0x00 ,0x67 ,0x66 ,0x0F,
	0xB7 ,0x5A ,0x0C ,0x66 ,0x81 ,0xE3 ,0xFF ,0x00 ,0x00 ,0x00 ,0x0F ,0x85 ,0x2E ,0x00 ,0x66 ,0x8B,
	0xDA ,0x68 ,0x00 ,0x20 ,0x07 ,0x66 ,0x2B ,0xFF ,0x66 ,0xA1 ,0x3E ,0x02 ,0xE8 ,0xC7 ,0xF3 ,0x68,
	0x00 ,0x20 ,0x1F ,0x66 ,0x33 ,0xD2 ,0x67 ,0x8A ,0x0A ,0x80 ,0xF9 ,0x00 ,0x0F ,0x84 ,0x0C ,0x00,
	0x66 ,0x61 ,0x90 ,0x1F ,0x07 ,0x66 ,0xB8 ,0x01 ,0x00 ,0x00 ,0x00 ,0xC3 ,0x66 ,0x61 ,0x90 ,0x1F,
	0x07 ,0x66 ,0xB8 ,0x00 ,0x00 ,0x00 ,0x00 ,0xC3 ,0x06 ,0x1E ,0x66 ,0x60 ,0x8A ,0x16 ,0x0E ,0x00,
	0xFE ,0xC2 ,0x2B ,0x26 ,0x0B ,0x00 ,0xB8 ,0x01 ,0x02 ,0x32 ,0xED ,0xB1 ,0x01 ,0x32 ,0xF6 ,0x16,
	0x07 ,0x8B ,0xDC ,0xCD ,0x13 ,0x0F ,0x82 ,0x37 ,0x00 ,0xB9 ,0x04 ,0x00 ,0x8B ,0xEB ,0x81 ,0xC5,
	0xBE ,0x01 ,0x80 ,0x7E ,0x00 ,0x00 ,0x0F ,0x8C ,0x0B ,0x00 ,0x83 ,0xC5 ,0x10 ,0xE2 ,0xF3 ,0x03,
	0x26 ,0x0B ,0x00 ,0xEB ,0xCB ,0x68 ,0x00 ,0x00 ,0x07 ,0x16 ,0x1F ,0x8B ,0xF3 ,0xBF ,0x00 ,0x7C,
	0xB9 ,0x00 ,0x02 ,0xFC ,0xF3 ,0xA4 ,0xE8 ,0xDB ,0xFD ,0x68 ,0x00 ,0x00 ,0x68 ,0x00 ,0x7C ,0xCB,
	0x03 ,0x26 ,0x0B ,0x00 ,0x66 ,0x61 ,0x90 ,0x1F ,0x07 ,0xC3 ,0xA1 ,0x17 ,0x03 ,0xE9 ,0x69 ,0xEE,
	0xA1 ,0xF8 ,0x01 ,0xE9 ,0x63 ,0xEE ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00

};

const BYTE FAT32_PBR[] =
{
	0x33,0xC9,0x8E,0xD1,0xBC,0xF4,0x7B,0x8E,0xC1,0x8E,0xD9,0xBD,0x00,0x7C,0x88,0x56,
	0x40,0x88,0x4E,0x02,0x8A,0x56,0x40,0xB4,0x41,0xBB,0xAA,0x55,0xCD,0x13,0x72,0x10,
	0x81,0xFB,0x55,0xAA,0x75,0x0A,0xF6,0xC1,0x01,0x74,0x05,0xFE,0x46,0x02,0xEB,0x2D,
	0x8A,0x56,0x40,0xB4,0x08,0xCD,0x13,0x73,0x05,0xB9,0xFF,0xFF,0x8A,0xF1,0x66,0x0F,
	0xB6,0xC6,0x40,0x66,0x0F,0xB6,0xD1,0x80,0xE2,0x3F,0xF7,0xE2,0x86,0xCD,0xC0,0xED,
	0x06,0x41,0x66,0x0F,0xB7,0xC9,0x66,0xF7,0xE1,0x66,0x89,0x46,0xF8,0x83,0x7E,0x16,
	0x00,0x75,0x39,0x83,0x7E,0x2A,0x00,0x77,0x33,0x66,0x8B,0x46,0x1C,0x66,0x83,0xC0,
	0x0C,0xBB,0x00,0x80,0xB9,0x01,0x00,0xE8,0x2C,0x00,0xE9,0xA8,0x03,0xA1,0xF8,0x7D,
	0x80,0xC4,0x7C,0x8B,0xF0,0xAC,0x84,0xC0,0x74,0x17,0x3C,0xFF,0x74,0x09,0xB4,0x0E,
	0xBB,0x07,0x00,0xCD,0x10,0xEB,0xEE,0xA1,0xFA,0x7D,0xEB,0xE4,0xA1,0x7D,0x80,0xEB,
	0xDF,0x98,0xCD,0x16,0xCD,0x19,0x66,0x60,0x80,0x7E,0x02,0x00,0x0F,0x84,0x20,0x00,
	0x66,0x6A,0x00,0x66,0x50,0x06,0x53,0x66,0x68,0x10,0x00,0x01,0x00,0xB4,0x42,0x8A,
	0x56,0x40,0x8B,0xF4,0xCD,0x13,0x66,0x58,0x66,0x58,0x66,0x58,0x66,0x58,0xEB,0x33,
	0x66,0x3B,0x46,0xF8,0x72,0x03,0xF9,0xEB,0x2A,0x66,0x33,0xD2,0x66,0x0F,0xB7,0x4E,
	0x18,0x66,0xF7,0xF1,0xFE,0xC2,0x8A,0xCA,0x66,0x8B,0xD0,0x66,0xC1,0xEA,0x10,0xF7,
	0x76,0x1A,0x86,0xD6,0x8A,0x56,0x40,0x8A,0xE8,0xC0,0xE4,0x06,0x0A,0xCC,0xB8,0x01,
	0x02,0xCD,0x13,0x66,0x61,0x0F,0x82,0x74,0xFF,0x81,0xC3,0x00,0x02,0x66,0x40,0x49,
	0x75,0x94,0xC3,0x42,0x4F,0x4F,0x54,0x4D,0x47,0x52,0x20,0x20,0x20,0x20,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0D,0x0A,0x44,0x69,0x73,0x6B,0x20,0x65,0x72,0x72,0x6F,0x72,0xFF,0x0D,
	0x0A,0x50,0x72,0x65,0x73,0x73,0x20,0x61,0x6E,0x79,0x20,0x6B,0x65,0x79,0x20,0x74,
	0x6F,0x20,0x72,0x65,0x73,0x74,0x61,0x72,0x74,0x0D,0x0A,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xAC,0x01,
	0xB9,0x01,0x00,0x00,0x55,0xAA,0x52,0x52,0x61,0x41,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x72,0x72,0x41,0x61,0xFF,0xFF,
	0xFF,0xFF,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x55,0xAA,0x0D,0x0A,0x41,0x6E,0x20,0x6F,0x70,0x65,0x72,0x61,
	0x74,0x69,0x6E,0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6D,0x20,0x77,0x61,0x73,0x6E,
	0x27,0x74,0x20,0x66,0x6F,0x75,0x6E,0x64,0x2E,0x20,0x54,0x72,0x79,0x20,0x64,0x69,
	0x73,0x63,0x6F,0x6E,0x6E,0x65,0x63,0x74,0x69,0x6E,0x67,0x20,0x61,0x6E,0x79,0x20,
	0x64,0x72,0x69,0x76,0x65,0x73,0x20,0x74,0x68,0x61,0x74,0x20,0x64,0x6F,0x6E,0x27,
	0x74,0x0D,0x0A,0x63,0x6F,0x6E,0x74,0x61,0x69,0x6E,0x20,0x61,0x6E,0x20,0x6F,0x70,
	0x65,0x72,0x61,0x74,0x69,0x6E,0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6D,0x2E,0xFF,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x04,0x66,0x0F,0xB6,0x46,0x10,0x66,0x8B,0x4E,0x24,0x66,0xF7,
	0xE1,0x66,0x03,0x46,0x1C,0x66,0x0F,0xB7,0x56,0x0E,0x66,0x03,0xC2,0x66,0x89,0x46,
	0xFC,0x66,0xC7,0x46,0xF4,0xFF,0xFF,0xFF,0xFF,0x66,0x8B,0x46,0x2C,0x66,0x83,0xF8,
	0x02,0x0F,0x82,0x47,0xFC,0x66,0x3D,0xF8,0xFF,0xFF,0x0F,0x0F,0x83,0x3D,0xFC,0x66,
	0x50,0x66,0x83,0xE8,0x02,0x66,0x0F,0xB6,0x5E,0x0D,0x8B,0xF3,0x66,0xF7,0xE3,0x66,
	0x03,0x46,0xFC,0xBB,0x00,0x82,0x8B,0xFB,0xB9,0x01,0x00,0xE8,0x28,0xFC,0x38,0x2D,
	0x74,0x1E,0xB1,0x0B,0x56,0xBE,0x6D,0x7D,0xF3,0xA6,0x5E,0x74,0x1B,0x03,0xF9,0x83,
	0xC7,0x15,0x3B,0xFB,0x72,0xE8,0x4E,0x75,0xDA,0x66,0x58,0xE8,0x65,0x00,0x72,0xBF,
	0x83,0xC4,0x04,0xE9,0xF6,0xFB,0x00,0x20,0x83,0xC4,0x04,0x8B,0x75,0x09,0x8B,0x7D,
	0x0F,0x8B,0xC6,0x66,0xC1,0xE0,0x10,0x8B,0xC7,0x66,0x83,0xF8,0x02,0x0F,0x82,0xDB,
	0xFB,0x66,0x3D,0xF8,0xFF,0xFF,0x0F,0x0F,0x83,0xD1,0xFB,0x66,0x50,0x66,0x83,0xE8,
	0x02,0x66,0x0F,0xB6,0x4E,0x0D,0x66,0xF7,0xE1,0x66,0x03,0x46,0xFC,0xBB,0x00,0x00,
	0x06,0x8E,0x06,0x00,0x81,0xE8,0xBE,0xFB,0x07,0x66,0x58,0xC1,0xEB,0x04,0x01,0x1E,
	0x00,0x81,0xE8,0x0E,0x00,0x0F,0x83,0x02,0x00,0x72,0xD0,0x8A,0x56,0x40,0xEA,0x00,
	0x00,0x00,0x20,0x66,0xC1,0xE0,0x02,0xE8,0x11,0x00,0x26,0x66,0x8B,0x01,0x66,0x25,
	0xFF,0xFF,0xFF,0x0F,0x66,0x3D,0xF8,0xFF,0xFF,0x0F,0xC3,0xBF,0x00,0x7E,0x66,0x0F,
	0xB7,0x4E,0x0B,0x66,0x33,0xD2,0x66,0xF7,0xF1,0x66,0x3B,0x46,0xF4,0x74,0x3A,0x66,
	0x89,0x46,0xF4,0x66,0x03,0x46,0x1C,0x66,0x0F,0xB7,0x4E,0x0E,0x66,0x03,0xC1,0x66,
	0x0F,0xB7,0x5E,0x28,0x83,0xE3,0x0F,0x74,0x16,0x3A,0x5E,0x10,0x0F,0x83,0x4C,0xFB,
	0x52,0x66,0x8B,0xC8,0x66,0x8B,0x46,0x24,0x66,0xF7,0xE3,0x66,0x03,0xC1,0x5A,0x52,
	0x8B,0xDF,0xB9,0x01,0x00,0xE8,0x3E,0xFB,0x5A,0x8B,0xDA,0xC3,0x00,0x00,0x00,0x00,

};

const BYTE FAT_PBR[] =
{
	0x33,0xC9,
	0x8E,0xD1,0xBC,0xF0,0x7B,0x8E,0xD9,0xB8,0x00,0x20,0x8E,0xC0,0xFC,0xBD,0x00,0x7C,
	0x38,0x4E,0x24,0x7D,0x24,0x8B,0xC1,0x99,0xE8,0x3C,0x01,0x72,0x1C,0x83,0xEB,0x3A,
	0x66,0xA1,0x1C,0x7C,0x26,0x66,0x3B,0x07,0x26,0x8A,0x57,0xFC,0x75,0x06,0x80,0xCA,
	0x02,0x88,0x56,0x02,0x80,0xC3,0x10,0x73,0xEB,0x33,0xC9,0x8A,0x46,0x10,0x98,0xF7,
	0x66,0x16,0x03,0x46,0x1C,0x13,0x56,0x1E,0x03,0x46,0x0E,0x13,0xD1,0x8B,0x76,0x11,
	0x60,0x89,0x46,0xFC,0x89,0x56,0xFE,0xB8,0x20,0x00,0xF7,0xE6,0x8B,0x5E,0x0B,0x03,
	0xC3,0x48,0xF7,0xF3,0x01,0x46,0xFC,0x11,0x4E,0xFE,0x61,0xBF,0x00,0x00,0xE8,0xE6,
	0x00,0x72,0x39,0x26,0x38,0x2D,0x74,0x17,0x60,0xB1,0x0B,0xBE,0xA1,0x7D,0xF3,0xA6,
	0x61,0x74,0x32,0x4E,0x74,0x09,0x83,0xC7,0x20,0x3B,0xFB,0x72,0xE6,0xEB,0xDC,0xA0,
	0xFB,0x7D,0xB4,0x7D,0x8B,0xF0,0xAC,0x98,0x40,0x74,0x0C,0x48,0x74,0x13,0xB4,0x0E,
	0xBB,0x07,0x00,0xCD,0x10,0xEB,0xEF,0xA0,0xFD,0x7D,0xEB,0xE6,0xA0,0xFC,0x7D,0xEB,
	0xE1,0xCD,0x16,0xCD,0x19,0x26,0x8B,0x55,0x1A,0x52,0xB0,0x01,0xBB,0x00,0x00,0xE8,
	0x3B,0x00,0x72,0xE8,0x5B,0x8A,0x56,0x24,0xBE,0x0B,0x7C,0x8B,0xFC,0xC7,0x46,0xF0,
	0x3D,0x7D,0xC7,0x46,0xF4,0x29,0x7D,0x8C,0xD9,0x89,0x4E,0xF2,0x89,0x4E,0xF6,0xC6,
	0x06,0x96,0x7D,0xCB,0xEA,0x03,0x00,0x00,0x20,0x0F,0xB6,0xC8,0x66,0x8B,0x46,0xF8,
	0x66,0x03,0x46,0x1C,0x66,0x8B,0xD0,0x66,0xC1,0xEA,0x10,0xEB,0x5E,0x0F,0xB6,0xC8,
	0x4A,0x4A,0x8A,0x46,0x0D,0x32,0xE4,0xF7,0xE2,0x03,0x46,0xFC,0x13,0x56,0xFE,0xEB,
	0x4A,0x52,0x50,0x06,0x53,0x6A,0x01,0x6A,0x10,0x91,0x8B,0x46,0x18,0x96,0x92,0x33,
	0xD2,0xF7,0xF6,0x91,0xF7,0xF6,0x42,0x87,0xCA,0xF7,0x76,0x1A,0x8A,0xF2,0x8A,0xE8,
	0xC0,0xCC,0x02,0x0A,0xCC,0xB8,0x01,0x02,0x80,0x7E,0x02,0x0E,0x75,0x04,0xB4,0x42,
	0x8B,0xF4,0x8A,0x56,0x24,0xCD,0x13,0x61,0x61,0x72,0x0B,0x40,0x75,0x01,0x42,0x03,
	0x5E,0x0B,0x49,0x75,0x06,0xF8,0xC3,0x41,0xBB,0x00,0x00,0x60,0x66,0x6A,0x00,0xEB,
	0xB0,0x42,0x4F,0x4F,0x54,0x4D,0x47,0x52,0x20,0x20,0x20,0x20,0x0D,0x0A,0x42,0x4F,
	0x4F,0x54,0x4D,0x47,0x52,0x20,0x69,0x73,0x20,0x6D,0x69,0x73,0x73,0x69,0x6E,0x67,
	0xFF,0x0D,0x0A,0x44,0x69,0x73,0x6B,0x20,0x65,0x72,0x72,0x6F,0x72,0xFF,0x0D,0x0A,
	0x50,0x72,0x65,0x73,0x73,0x20,0x61,0x6E,0x79,0x20,0x6B,0x65,0x79,0x20,0x74,0x6F,
	0x20,0x72,0x65,0x73,0x74,0x61,0x72,0x74,0x0D,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xAC,0xC1,0xCE,0x55,0xAA,
};

LSTATUS DiskUpdateBootCode(LPCWSTR BootPartition)
{
	CHFile hRootPath = CreateFile(BootPartition, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);

	if (hRootPath.IsInvalid())
		return GetLastError_s();


	PARTITION_INFORMATION_EX PartitionInfo = {};
	DWORD cbPartitionInfo = 0;

	if (DeviceIoControl(hRootPath, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &PartitionInfo, sizeof(PARTITION_INFORMATION_EX), &cbPartitionInfo, NULL) == FALSE)
		return GetLastError_s();


	if (PartitionInfo.PartitionStyle != PARTITION_STYLE::PARTITION_STYLE_MBR)
	{
		return ERROR_INVALID_PARAMETER;
	}

	/*如果不是一个主分区那么返回环境错误*/
	if (PartitionInfo.PartitionLength.QuadPart == 0 || PartitionInfo.Mbr.PartitionType == PARTITION_EXTENDED || PartitionInfo.Mbr.PartitionType == PARTITION_XINT13_EXTENDED)
	{
		return ERROR_BAD_ENVIRONMENT;
	}


	wchar_t FileSystemNameSize[MAX_PATH + 1] = {};

	if (!GetVolumeInformationByHandleW(hRootPath, NULL, 0, NULL, NULL, NULL, FileSystemNameSize, ArraySize(FileSystemNameSize)))
		return GetLastError_s();


	BYTE PBR[10 * 512];

	DWORD cbData;

	if (!ReadFile(hRootPath, PBR, sizeof(PBR), &cbData, NULL))
		return GetLastError_s();

	if (cbData != sizeof(PBR))
		return ERROR_INVALID_FUNCTION;

	bool NeedUpdate = false;

	if (StrCmp(FileSystemNameSize, L"NTFS") == 0)
	{
		//分区类型是NTFS,偏移0x54开始就是启动信息
		if (*(UINT16*)PBR == 0x52EB)
		{
			if (NeedUpdate = memcmp(PBR + 0x54, NTFS_PBR, sizeof(NTFS_PBR)))
			{
				memcpy(PBR + 0x54, NTFS_PBR, sizeof(NTFS_PBR));
			}
		}
	}
	else if (StrCmp(FileSystemNameSize, L"FAT32") == 0)
	{
		//分区类型是NTFS,偏移0x5A开始就是启动信息
		if (*(UINT16*)PBR == 0x58EB)
		{
			if (NeedUpdate = memcmp(PBR + 0x5A, FAT32_PBR, sizeof(FAT32_PBR)))
			{
				memcpy(PBR + 0x5A, FAT32_PBR, sizeof(FAT32_PBR));
			}
		}

	}
	else if (StrCmp(FileSystemNameSize, L"FAT") == 0)
	{
		//分区类型是NTFS,偏移0x5A开始就是启动信息
		if (*(UINT16*)PBR == 0x3CEB)
		{
			if (NeedUpdate = memcmp(PBR + 0x3E, FAT_PBR, sizeof(FAT_PBR)))
			{
				memcpy(PBR + 0x3E, FAT_PBR, sizeof(FAT_PBR));
			}
		}
	}
	else
	{
		return ERROR_BAD_FORMAT;
	}

	//对比当前启动代码,如果不同，那么更新启动代码
	if (NeedUpdate)
	{
		DeviceIoControl(hRootPath, FSCTL_LOCK_VOLUME, NULL, 0, NULL, NULL, &cbData, NULL);


		//将启动代码复制到启动分区
		SetFilePointer(hRootPath, 0, NULL, FILE_BEGIN);



		WriteFile(hRootPath, PBR, sizeof(PBR), &cbData, NULL);

		DeviceIoControl(hRootPath, FSCTL_UNLOCK_VOLUME, NULL, 0, NULL, NULL, &cbData, NULL);

	}

	//扫描硬盘下标
	VOLUME_LOGICAL_OFFSET LogicalOffset = {};
	VOLUME_PHYSICAL_OFFSETS PhysicalOffsets = {};
	DWORD cbRet = 0;

	if (!DeviceIoControl(hRootPath, IOCTL_VOLUME_LOGICAL_TO_PHYSICAL, &LogicalOffset, sizeof(LogicalOffset), &PhysicalOffsets, sizeof(PhysicalOffsets), &cbRet, NULL))
	{
		return GetLastError_s();
	}

	hRootPath = CreateFile(StrFormat(L"\\\\.\\PhysicalDrive%u", PhysicalOffsets.PhysicalOffset->DiskNumber), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);

	if (hRootPath.IsInvalid())
		return GetLastError_s();


	DISK_GEOMETRY DismGeoMetry;

	if (!DeviceIoControl(hRootPath, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &DismGeoMetry, sizeof(DismGeoMetry), &cbRet, NULL))
	{
		return GetLastError_s();
	}


	CStringA MbrBuffer;

	//std::vector<byte>MbrBuffer(DismGeoMetry.BytesPerSector);

	auto pMbr = (MASTER_BOOT_RECORD*)MbrBuffer.GetBuffer(DismGeoMetry.BytesPerSector);




	DWORD cbReat = 0;

	if (ReadFile(hRootPath, pMbr, DismGeoMetry.BytesPerSector, &cbReat, NULL) == FALSE || cbReat != DismGeoMetry.BytesPerSector)
	{
		return ERROR_INVALID_FUNCTION;
	}

	if (!PartitionInfo.Mbr.BootIndicator)
	{
		bool HaveBoot = false;
		PartitionInfo.StartingOffset.QuadPart = PartitionInfo.StartingOffset.QuadPart / DismGeoMetry.BytesPerSector;

		for (int i = 0; i != ArraySize(pMbr->PartitionRecord); i++)
		{
			if (pMbr->PartitionRecord[i].SizeInLBA&&pMbr->PartitionRecord[i].StartingLBA == PartitionInfo.StartingOffset.LowPart)
			{
				pMbr->PartitionRecord[i].BootIndicator = 0x80;
				HaveBoot = true;
			}
			else
			{
				pMbr->PartitionRecord[i].BootIndicator = 0;
			}
		}

		if (!HaveBoot)
		{
			return ERROR_INVALID_FUNCTION;
		}
	}

	memcpy(pMbr->BootCode, NtMbr, sizeof(NtMbr));


	//pMbr->PartitionRecord[PartitionInfo.PartitionNumber - 1].BootIndicator = 0x80;

	SetFilePointer(hRootPath, 0, NULL, FILE_BEGIN);

	return WriteFile(hRootPath, pMbr, DismGeoMetry.BytesPerSector, &cbReat, NULL) ? ERROR_SUCCESS : GetLastError_s();
}


LSTATUS DiskGetPartitionStyle(LPCWSTR Partition, PARTITION_STYLE* pPartitionStyle)
{
	CHFile hRootPath = CreateFile(Partition, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);

	if (hRootPath.IsInvalid())
		return GetLastError_s();

	PARTITION_INFORMATION_EX PartitionInfo = {};
	DWORD cbPartitionInfo = 0;

	if (DeviceIoControl(hRootPath, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &PartitionInfo, sizeof(PARTITION_INFORMATION_EX), &cbPartitionInfo, NULL) == FALSE)
	{
		return GetLastError_s();
	}
	else
	{
		*pPartitionStyle = PartitionInfo.PartitionStyle;
		return ERROR_SUCCESS;
	}
}



CString Guid2Str(const GUID& guid)
{
	CString Temp;
	Temp.Format(L"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"
		, guid.Data1
		, guid.Data2
		, guid.Data3
		, guid.Data4[0], guid.Data4[1]
		, guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5]
		, guid.Data4[6], guid.Data4[7]);

	return Temp;
}

template<class Ch>
bool Str2Guid_t(const Ch* String, GUID& Guid)
{
	if (*String == L'{')
	{
		//{0ce4991b-e6b3-4b16-b23c-5e0d9250e5d9}
		if (StrLen(String) != 38 || String[37] != Ch('}') || String[38] != Ch('\0'))
		{
			return false;
		}

		++String;
	}
	else
	{
		//0ce4991b-e6b3-4b16-b23c-5e0d9250e5d9
		if (StrLen(String) != 36 || String[36] != Ch('\0'))
		{
			return false;
		}
	}


	for (int index = 0; index != 36; ++index)
	{
		switch (index)
		{
		case 8:
		case 13:
		case 18:
		case 23:
			if (String[index] != Ch('-'))
				return false;
			break;
		default:
			if (String[index] >= Ch('0') && String[index] <= ('9')
				|| String[index] >= Ch('A') && String[index] <= Ch('F')
				|| String[index] >= Ch('a') && String[index] <= Ch('f'))
			{

			}
			else
			{
				return false;
			}

			break;
		}
	}


	Guid.Data1 = Char2Hex(String[0]) << 28 | Char2Hex(String[1]) << 24 | Char2Hex(String[2]) << 20 | Char2Hex(String[3]) << 16
		| Char2Hex(String[4]) << 12 | Char2Hex(String[5]) << 8 | Char2Hex(String[6]) << 4 | Char2Hex(String[7]) << 0;

	Guid.Data2 = Char2Hex(String[9]) << 12 | Char2Hex(String[10]) << 8 | Char2Hex(String[11]) << 4 | Char2Hex(String[12]) << 0;

	Guid.Data3 = Char2Hex(String[14]) << 12 | Char2Hex(String[15]) << 8 | Char2Hex(String[16]) << 4 | Char2Hex(String[17]) << 0;

	Guid.Data4[0] = Char2Hex(String[19]) << 4 | Char2Hex(String[20]) << 0;
	Guid.Data4[1] = Char2Hex(String[21]) << 4 | Char2Hex(String[22]) << 0;
	Guid.Data4[2] = Char2Hex(String[24]) << 4 | Char2Hex(String[25]) << 0;
	Guid.Data4[3] = Char2Hex(String[26]) << 4 | Char2Hex(String[27]) << 0;
	Guid.Data4[4] = Char2Hex(String[28]) << 4 | Char2Hex(String[29]) << 0;
	Guid.Data4[5] = Char2Hex(String[30]) << 4 | Char2Hex(String[31]) << 0;
	Guid.Data4[6] = Char2Hex(String[32]) << 4 | Char2Hex(String[33]) << 0;
	Guid.Data4[7] = Char2Hex(String[34]) << 4 | Char2Hex(String[35]) << 0;

	return true;
}

bool Str2Guid(LPCWSTR String, GUID& Guid)
{
	return Str2Guid_t(String, Guid);
}

bool Str2Guid(LPCSTR String, GUID& Guid)
{
	return Str2Guid_t(String, Guid);
}


GUID Str2Guid(LPCWSTR String)
{
	GUID Temp = {};

	auto bSuccess = Str2Guid(String, Temp);

	assert(bSuccess);

	return Temp;
}


void FindPath(CStringI FilePath, LPCWSTR SubStr, std::set<CStringI>&FindList, DWORD cchRootPath)
{
	int cchFilePath = FilePath.GetLength();

	LPCWSTR Str = StrChr(SubStr, L'*');
	if (Str == NULL)
	{
		FindList.insert((FilePath + SubStr).GetString() + cchRootPath);
		return;
	}
	else
	{
		Str = StrChr(Str, L'\\');
		if (Str == NULL)
		{
			FilePath += SubStr;
			//std::swap(Str, SubStr);

		}
		else
		{
			FilePath.Append(SubStr, Str - SubStr);
			Str += 1;
		}
	}

	WIN32_FIND_DATAW FindFileData;
	HANDLE hFileFind = FindFirstFileW(FilePath, &FindFileData);
	FilePath.ReleaseBufferSetLength(FilePath.ReverseFind(L'\\') + 1);

	if (hFileFind != INVALID_HANDLE_VALUE)
	{
		do
		{
			if (_IsDots(FindFileData.cFileName) == 0)
			{
				if (Str == NULL)
				{
					FindList.insert((FilePath + FindFileData.cFileName).GetString() + cchRootPath);
				}
				else if (FindFileData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY)
				{
					if (*Str)
					{
						FindPath(FilePath + FindFileData.cFileName + L'\\', Str, FindList, cchRootPath);
					}
					else
					{
						FindList.insert((FilePath + FindFileData.cFileName + L'\\').GetString() + cchRootPath);
					}
				}
			}

		} while (FindNextFile(hFileFind, &FindFileData));


		FindClose(hFileFind);
	}
}


//CTime GetCompileDateTime()
//{
//	const int  MONTH_PER_YEAR = 12;
//	const char szEnglishMonth[MONTH_PER_YEAR][4] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
//	//char szTmpDate[40]={0};
//	//char szTmpTime[20]={0};
//	char szMonth[4] = { 0 };
//	int iYear, iMonth, iDay/*, iHour, iMin, iSec*/;
//
//	//获取编译日期、时间
//	//sprintf(szTmpDate,"%s",__DATE__);
//	//sprintf(szTmpTime,"%s",__TIME__);
//
//	sscanf(__DATE__, "%s %d %d", szMonth, &iDay, &iYear);
//	//sscanf(__TIME__, "%d:%d:%d", &iHour, &iMin, &iSec);
//
//	for (int i = 0; MONTH_PER_YEAR; i++)
//	{
//		if (strncmp(szMonth, szEnglishMonth[i], 3) == 0)
//		{
//			iMonth = i + 1;
//			break;
//		}
//	}
//	return CTime(iYear, iMonth, iDay, 0, 0, 0);
//}

//static HRESULT RegOpenKeyEx




CString StrCut(CString String, DWORD MaxLen, wchar_t ch)
{
	//删除特殊字符
	for (auto i = String.GetLength() - 1;i != -1;--i)
	{
		switch (String[i])
		{
		case L'(':
		case L')':
		case L' ':
			String.Delete(i);
		default:
			break;
		}
	}


	if (String.GetLength()>MaxLen)
	{
		MaxLen = MaxLen / 2;

		String.Delete(MaxLen, String.GetLength() - MaxLen*2);

		String.SetAt(MaxLen-1, ch);
		String.SetAt(MaxLen, ch);
	}
	return String;
}





LSTATUS RunCmd(LPCWSTR FilePath, CString CmdString, CString* pOutString)
{
	SECURITY_ATTRIBUTES sa;
	HANDLE hRead, hWrite;

	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;
	if (!CreatePipe(&hRead, &hWrite, &sa, 0))
	{
		return GetLastError_s();
	}

	STARTUPINFO si = { sizeof(STARTUPINFO) };
	PROCESS_INFORMATION pi;

	GetStartupInfo(&si);
	si.hStdError = hWrite;
	si.hStdOutput = hWrite;
	si.wShowWindow = SW_HIDE;
	si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
	//关键步骤，CreateProcess函数参数意义请查阅MSDN
	//auto TT= EXECDOSCMD.GetBuffer();

	wchar_t SystempPath[MAX_PATH + 1];

	GetSystemDirectory(SystempPath, ArraySize(SystempPath));

	if (!CreateProcessW(FilePath, CmdString.GetBuffer(), NULL, NULL, TRUE, CREATE_UNICODE_ENVIRONMENT, NULL, SystempPath, &si, &pi))
	{
		return GetLastError_s();
	}

	CloseHandle(hWrite);

	DWORD bytesRead;

	CStringA OutString;
	//OutString.reserve(1024);

	//OutString.GetBuffer(1024);
	while (ReadFile(hRead, OutString.GetBuffer(OutString.GetLength() + 1024) + OutString.GetLength(), 1024, &bytesRead, NULL) && bytesRead)
	{
		OutString.ReleaseBufferSetLength(OutString.GetLength() + bytesRead);

		//OutString._Mylast() += bytesRead;
		//OutString.reserve(OutString.size() + 1024);


		//buffer中就是执行的结果，可以保存到文本，也可以直接输出
		//TRACE(buffer);
		//等待10毫秒

		Sleep(5);

	}

	CloseHandle(hRead);

	WaitForSingleObject(pi.hProcess, INFINITE);

	LSTATUS lStatus = ERROR_INVALID_FUNCTION;

	GetExitCodeProcess(pi.hProcess, (LPDWORD)&lStatus);


	CloseHandle(pi.hThread);
	CloseHandle(pi.hProcess);

	//*OutString._Mylast() = NULL;
	if (pOutString)
	{
		*pOutString = OutString;
	}


	//EXECDOSCMD.
	return lStatus;
}

LSTATUS RunCmd(LPCWSTR FilePath, CString CmdString, BaseCallBack CallBack, LPVOID UserData)
{
	STARTUPINFO si = { sizeof(STARTUPINFO) };
	PROCESS_INFORMATION pi = {};

	//GetStartupInfo(&si);

	si.wShowWindow = SW_HIDE;
	si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
	//关键步骤，CreateProcess函数参数意义请查阅MSDN
	//auto TT= EXECDOSCMD.GetBuffer();

	//wchar_t SystempPath[MAX_PATH + 1];

	//GetSystemDirectory(SystempPath, ArraySize(SystempPath));

	if (!CreateProcessW(FilePath, CmdString.GetBuffer(), NULL, NULL, FALSE, CREATE_UNICODE_ENVIRONMENT, NULL, NULL, &si, &pi))
	{
		return GetLastError_s();
	}

	CloseHandle(pi.hThread);

	if (CallBack)
	{
		while (WaitForSingleObject(pi.hProcess,500)==WAIT_TIMEOUT)
		{
			if (CallBack(/*Dism_MSG_QUERY_ABORT*/ 38030, 0, 0, UserData))
			{
				TerminateProcess(pi.hProcess,ERROR_CANCELLED);
				CloseHandle(pi.hProcess);

				return ERROR_CANCELLED;
			}
		}
	}
	else
	{
		WaitForSingleObject(pi.hProcess, -1);
	}

	DWORD ExitCore = 1;

	GetExitCodeProcess(pi.hProcess, &ExitCore);

	CloseHandle(pi.hProcess);

	return ExitCore;

}

LSTATUS RunCmd(LPCWSTR FilePath, CString CmdString, bool Async)
{
	STARTUPINFO si = { sizeof(STARTUPINFO) };
	PROCESS_INFORMATION pi = {};

	//GetStartupInfo(&si);

	si.wShowWindow = SW_HIDE;
	si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
	//关键步骤，CreateProcess函数参数意义请查阅MSDN
	//auto TT= EXECDOSCMD.GetBuffer();

	//wchar_t SystempPath[MAX_PATH + 1];

	//GetSystemDirectory(SystempPath, ArraySize(SystempPath));

	if (!CreateProcessW(FilePath, CmdString.GetBuffer(), NULL, NULL, FALSE, CREATE_UNICODE_ENVIRONMENT, NULL, NULL, &si, &pi))
	{
		return GetLastError_s();
	}

	if (Async)
	{
		CloseHandle(pi.hThread);
		CloseHandle(pi.hProcess);
		return ERROR_SUCCESS;
	}
	else
	{
		WaitForSingleObject(pi.hProcess, -1);
		DWORD ExitCore = E_FAIL;

		GetExitCodeProcess(pi.hProcess, &ExitCore);

		CloseHandle(pi.hThread);
		CloseHandle(pi.hProcess);

		return ExitCore;
	}
}





//static BOOL CheckProc(LPCWSTR DllName, LPCSTR ProcName)
//{
//	HMODULE hDll = LoadLibraryW(DllName);
//
//	BOOL Ret = FALSE;
//
//	if (hDll)
//	{
//		if (GetProcAddress(hDll, ProcName))
//		{
//			Ret = TRUE;
//		}
//
//		FreeLibrary(hDll);
//	}
//	return Ret;
//}


HRESULT SanInterface(IUnknown* pInterface)
{
	CComPtr<IDispatch> pIDispatch;
	HRESULT hr = pInterface->QueryInterface(&pIDispatch);

	if (FAILED(hr))
		return hr;

	//pIDispatch->

	return S_OK;
}





NTSTATUS QuerySymbolicLinkObject(LPCWSTR LinkName, CString& LinkTarget)
{
	HANDLE hH = INVALID_HANDLE_VALUE;

	UNICODE_STRING ObjectName;

	RtlInitUnicodeString(&ObjectName, LinkName);

	OBJECT_ATTRIBUTES oa = { sizeof(OBJECT_ATTRIBUTES), NULL, &ObjectName, OBJ_CASE_INSENSITIVE };

	auto Status = ZwOpenSymbolicLinkObject(&hH, GENERIC_READ, &oa);

	if (Status!= STATUS_SUCCESS)
		return Status;

	UNICODE_STRING _LinkTarget = { 0, MAX_PATH * 2, LinkTarget.GetBuffer(MAX_PATH) };

	ULONG ccbRet;


	Status = ZwQuerySymbolicLinkObject(hH, &_LinkTarget, &ccbRet);

	ZwClose(hH);

	if (Status == STATUS_SUCCESS)
	{
		LinkTarget.ReleaseBufferSetLength(_LinkTarget.Length >> 1);
	}

	return Status;
}

//用NTFS压缩压缩一个文件/文件夹
//HRESULT SetNTFSCompress(CString Path)
//{
//	HRESULT hr = 0, hr1;
//	USHORT Type = COMPRESSION_FORMAT_DEFAULT; //设置为极限压缩
//	DWORD Temp, Attributes;
//
//	WIN32_FIND_DATAW FindFileData;
//
//	HANDLE hFileFind = FindFirstFileW(Path + L"\\*", &FindFileData);
//
//	if (hFileFind != INVALID_HANDLE_VALUE)
//	{
//		do
//		{
//			if (FindFileData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY)
//			{
//				if (_IsDots(FindFileData.cFileName) == 0)
//				{
//					CString Text = Path + L"\\" + FindFileData.cFileName;
//					if ((hr1 = SetNTFSCompress(Path + L"\\" + FindFileData.cFileName)) != 0) hr = hr1;
//				}
//			}
//			else
//			{
//				if ((FindFileData.dwFileAttributes&FILE_ATTRIBUTE_COMPRESSED) == 0)
//				{
//					Attributes = GetFileAttributesW(Path + L"\\" + FindFileData.cFileName); //属性备份
//					SetFileAttributesW(Path + L"\\" + FindFileData.cFileName, FILE_ATTRIBUTE_NORMAL); //清除只读属性
//					HANDLE hFile = CreateFileW(Path + L"\\" + FindFileData.cFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);
//					if (hFile != INVALID_HANDLE_VALUE)
//					{
//						if (DeviceIoControl(hFile, FSCTL_SET_COMPRESSION, &Type, sizeof(Type), 0, 0, &Temp, 0) == FALSE) hr = GetLastError();
//						CloseHandle(hFile);
//					}
//					else hr = GetLastError();
//					SetFileAttributesW(Path + L"\\" + FindFileData.cFileName, Attributes); //恢复属性
//				}
//			}
//		} while (FindNextFile(hFileFind, &FindFileData));
//
//		FindClose(hFileFind);
//	}
//
//	if ((GetFileAttributesW(Path)&FILE_ATTRIBUTE_COMPRESSED) == 0)
//	{
//		Attributes = GetFileAttributesW(Path); //属性备份
//		SetFileAttributesW(Path, FILE_ATTRIBUTE_NORMAL); //清除只读属性
//		HANDLE hFile = CreateFileW(Path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);
//		if (hFile != INVALID_HANDLE_VALUE)
//		{
//			if (DeviceIoControl(hFile, FSCTL_SET_COMPRESSION, &Type, sizeof(Type), 0, 0, &Temp, 0) == FALSE) hr = GetLastError();
//			CloseHandle(hFile);
//		}
//		else hr = GetLastError();
//		SetFileAttributesW(Path, Attributes); //恢复属性
//	}
//	return hr;
//}

#if _MSC_VER >1500

HRESULT IsoCreateFileByPath(LPCWSTR pIsoPath, LPCWSTR SrcDir, LPCWSTR VolumeName, BaseCallBack callBack, LPVOID pUserData)
{
	ComInitializeWrapper ComWrapper;

	CString pSrcDir= SrcDir;
	if (pSrcDir[pSrcDir.GetLength() - 1] != L'\\')
		pSrcDir += L'\\';

#define BOOT_FILE_NAME_LEGACY _T("boot\\etfsboot.com") //CSM boot  
#define BOOT_FILE_NAME_UEFI   _T("efi\\microsoft\\boot\\efisys.bin") //UEFI boot  


	CComPtr<IFileSystemImage2> pSystemImage;

	auto hr = CoCreateInstance(__uuidof(MsftFileSystemImage),
		NULL,
		CLSCTX_INPROC_SERVER,
		__uuidof(IFileSystemImage2),
		(LPVOID*)&pSystemImage);

	if (FAILED(hr))
	{
		return hr;
	}

	
	hr = pSystemImage->put_VolumeName(CComBSTR(VolumeName ? VolumeName : L"ESD-ISO"));
	if (FAILED(hr))
	{
		return hr;
	}

	struct MediaInfo
	{
		IMAPI_MEDIA_PHYSICAL_TYPE Type;
		LONG FreeMediaBlocks;
	};
	
	const MediaInfo MediaTypes[]=
	{
		{ IMAPI_MEDIA_TYPE_DVDPLUSR, 2295104 },
		{ IMAPI_MEDIA_TYPE_DVDPLUSR_DUALLAYER, 4173824 },
		{ IMAPI_MEDIA_TYPE_HDDVDROM, 62500864 },
	};

	std::vector<IBootOptions*> vBootOptions;

	{
		CComPtr<IStream> pBootStream;
		SHCreateStreamOnFileW(pSrcDir + BOOT_FILE_NAME_LEGACY, STGM_READ | STGM_SHARE_DENY_WRITE, &pBootStream);
		if (pBootStream)
		{
			CComPtr<IBootOptions> BootOption;

			hr = CoCreateInstance(__uuidof(BootOptions), NULL, CLSCTX_INPROC_SERVER, __uuidof(IBootOptions), (void**)&BootOption);
			if (SUCCEEDED(hr))
			{
				BootOption->put_Manufacturer(CComBSTR(L"MBR"));
				BootOption->put_PlatformId(PlatformX86);
				BootOption->put_Emulation(EmulationNone);

				BootOption->AssignBootImage(pBootStream);

				vBootOptions.push_back(BootOption.Detach());
			}
		}
	}

	{
		CComPtr<IStream> pBootStream;
		SHCreateStreamOnFileW(pSrcDir + BOOT_FILE_NAME_UEFI, STGM_READ | STGM_SHARE_DENY_WRITE, &pBootStream);
		if (pBootStream)
		{
			CComPtr<IBootOptions> BootOption;

			hr = CoCreateInstance(__uuidof(BootOptions), NULL, CLSCTX_INPROC_SERVER, __uuidof(IBootOptions), (void**)&BootOption);
			if (SUCCEEDED(hr))
			{
				BootOption->put_Manufacturer(CComBSTR(L"UEFI"));
				BootOption->put_PlatformId(PlatformEFI);
				BootOption->put_Emulation(EmulationNone);

				BootOption->AssignBootImage(pBootStream);

				vBootOptions.push_back(BootOption.Detach());
			}
		}
	}
	SAFEARRAY * psa = NULL;

	if (auto Size = vBootOptions.size())
	{
		psa = SafeArrayCreateVector(VT_VARIANT, 0, Size);

		VARIANT* pData;

		SafeArrayAccessData(psa, (void**)&pData);

		for (int i = 0;i != Size;++i)
		{
			pData[i].vt = VT_DISPATCH;

			pData[i].pdispVal = vBootOptions[i];
		}
	}

	RunOnExit([&]()
	{
		if(psa)
			SafeArrayDestroy(psa);

		for (auto pItem : vBootOptions)
			pItem->Release();
	});

	if (psa)
	{
		SafeArrayUnaccessData(psa);

		pSystemImage->put_BootImageOptionsArray(psa);
	}

	CComPtr<IFsiDirectoryItem> pRootDirItem;

	//获取根条目
	hr = pSystemImage->get_Root(&pRootDirItem);

	if (FAILED(hr))
		return hr;

	//添加一个目录树到镜像
	CComBSTR TreeRoot(pSrcDir);

	for(auto& Info : MediaTypes)
	{
		pSystemImage->ChooseImageDefaultsForMediaType(Info.Type);

		pSystemImage->put_FreeMediaBlocks(Info.FreeMediaBlocks);

		hr = pRootDirItem->AddTree(TreeRoot, FALSE);

		if (FAILED(hr))
		{
			if (hr == /*IMAPI_E_IMAGE_SIZE_LIMIT*/0xC0AAB120L)
			{
				//超过极限呀小，继续调整映像类型
				continue;
			}
			else
			{
				//中断程序已经错误
				return hr;
			}
		}

			
		CComPtr<IFileSystemImageResult> pSystemImageResult;

		//创建一个包含文件系统和文件数据的结果对象
		hr = pSystemImage->CreateResultImage(&pSystemImageResult);

		//无法创建结果集
		if (FAILED(hr))
		{
			return hr;
		}

		CComPtr<IStream> pImageStream;

		//获取镜像流
		hr = pSystemImageResult->get_ImageStream(&pImageStream);
		//无法获取镜像流
		if (FAILED(hr))
		{
			return hr;
		}
		else
		{
			STATSTG			statstg;
			//ULARGE_INTEGER	ullRead;
			//ULARGE_INTEGER	ullWritten;

			CComPtr<IStream> pFileStream;

			//创建iso文件
			hr = SHCreateStreamOnFileEx(pIsoPath,
				STGM_READWRITE | STGM_CREATE,
				FILE_ATTRIBUTE_NORMAL,
				TRUE,
				NULL,
				&pFileStream);

			if (FAILED(hr))
			{
				return hr;
			}


			pImageStream->Stat(&statstg, STATFLAG_DEFAULT);

			CStringA BufferISO;
			auto pBuffer = BufferISO.GetBuffer(1024 * 1024);

			ULONG cbRead = 0;

			UINT64 cbReadAll = 0;


			//while ( == S_OK&&cbRead)
			for (;;)
			{
				cbRead = 0;
				auto thr = pImageStream->Read(pBuffer, 1024 * 1024, &cbRead);

				if (FAILED(thr))
				{
					hr = thr;
					break;
				}

				if (cbRead == 0)
					break;

				cbReadAll += cbRead;

				thr = pFileStream->Write(pBuffer, cbRead, &cbRead);

				if (FAILED(thr))
				{
					hr = thr;
					break;
				}

				if (callBack)
				{
					callBack(DISM_MSG_PROGRESS, cbReadAll * 100 / statstg.cbSize.QuadPart, 0, pUserData);

					if (callBack(38030, 0, 0, pUserData))
					{
						hr = __HRESULT_FROM_WIN32(ERROR_CANCELLED);
						break;
					}
				}
			}
		}

		if (FAILED( hr))
		{
			DeleteFile(pIsoPath);
			return hr;
		}
		else
		{
			return S_OK;
		}
	}

	return E_NOTIMPL;
}

#endif

LSTATUS Binary2Base64(const void* Src, DWORD ccbSrc, CString& Base64String)
{
	DWORD Dst = 0;

	if (!CryptBinaryToStringW(
		(const BYTE*)Src, ccbSrc,
		CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF,
		NULL, &Dst
	))
	{
		return GetLastError_s();
	}

	if(!CryptBinaryToStringW(
		(const BYTE*)Src, ccbSrc,
		CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF,
		Base64String.GetBuffer(Dst), &Dst))
	{
		return GetLastError_s();
	}

	Base64String.ReleaseBufferSetLength(Dst);

	return ERROR_SUCCESS;
}

LSTATUS Base642Binary(BYTE* pBinary, DWORD& ccbBinary, LPCSTR Base64String, DWORD cchString)
{
	if (cchString == -1)
		cchString = StrLen(Base64String);

	DWORD nLenOut = ccbBinary;

	if (!CryptStringToBinaryA(
		Base64String, cchString,
		CRYPT_STRING_BASE64,
		pBinary, &ccbBinary,
		NULL,        // pdwSkip (not needed)
		NULL         // pdwFlags (not needed)
	))
	{
		auto lStatus = GetLastError_s();

		if (lStatus == ERROR_MORE_DATA)
		{
			ccbBinary = cchString;
		}

		return lStatus;
	}

	return ERROR_SUCCESS;
}

LSTATUS Base642Binary(BYTE* pBinary, DWORD& ccbBinary, LPCWSTR Base64String, DWORD cchString)
{
	if (cchString == -1)
		cchString = StrLen(Base64String);

	DWORD nLenOut = ccbBinary;

	if (!CryptStringToBinaryW(
		Base64String, cchString,
		CRYPT_STRING_BASE64,
		pBinary, &ccbBinary,
		NULL,        // pdwSkip (not needed)
		NULL         // pdwFlags (not needed)
	))
	{
		auto lStatus = GetLastError_s();

		if (lStatus == ERROR_MORE_DATA)
		{
			ccbBinary = cchString;
		}

		return lStatus;
	}

	return ERROR_SUCCESS;
}


template<class Ch>
LSTATUS Base642BinaryT(CStringA& Binary, const Ch* Base64String, DWORD cchString)
{
	if (cchString == -1)
		cchString = StrLen(Base64String);

	//Binary.reserve(cchString);
	Binary.GetBuffer(cchString);

	DWORD nLenOut = Binary.GetAllocLength();

	auto lStatus = Base642Binary((BYTE*)Binary.GetBuffer(), nLenOut, Base64String, cchString);

	if (lStatus!=ERROR_SUCCESS)
	{
		//Binary._Mylast() = Binary._Myfirst() + nLenOut;
		return lStatus;
	}
	
	Binary.ReleaseBufferSetLength(nLenOut);

	return ERROR_SUCCESS;
}

LSTATUS Base642Binary(CStringA& Binary, LPCSTR Base64String, DWORD cchString)
{
	return Base642BinaryT(Binary, Base64String, cchString);
}

LSTATUS Base642Binary(CStringA& Binary, LPCWSTR Base64String, DWORD cchString)
{
	return Base642BinaryT(Binary, Base64String, cchString);
}

void ReverseBinary(BYTE* pBinary, DWORD ccbBinary)
{
	ccbBinary--;

	for (int i = ccbBinary / 2 - 1; i != -1; i--)
	{
		std::swap(pBinary[i], pBinary[ccbBinary - i]);
	}
}

BOOL PathIsSameVolume(LPCWSTR Path1, LPCWSTR Path2)
{
	wchar_t VolumePath1[MAX_PATH + 1], VolumePath2[MAX_PATH + 1];

	if (!GetVolumePathName(Path1, VolumePath1, ArraySize(VolumePath1)))
	{
		return FALSE;
	}

	if (!GetVolumePathName(Path2, VolumePath2, ArraySize(VolumePath2)))
	{
		return FALSE;
	}

	return PathIsSameRoot(VolumePath1, VolumePath2);
}


void UTF8ToUnicode(const char* Src, DWORD chSrc, CString& Dest)
{
	assert(chSrc != -1);

	chSrc=MultiByteToWideChar(CP_UTF8, 0, Src, chSrc, Dest.GetBuffer(chSrc), chSrc);

	Dest.ReleaseBufferSetLength(chSrc);
}

CString UTF8ToUnicode(const char* Src, DWORD cchSrc)
{
	CString Temp;

	UTF8ToUnicode(Src, cchSrc, Temp);

	return Temp;
}

CString UTF8ToUnicode(const char* Src)
{
	return UTF8ToUnicode(Src, StrLen(Src));
}



NTSTATUS AdjustPrivilege(ULONG Privilege, BOOL Enable)
{
	BOOLEAN IsEnable;

	return RtlAdjustPrivilege(Privilege, Enable, FALSE, &IsEnable);
}

LSTATUS GetHashByFilePath(LPCWSTR FilePath, ALG_ID Algid, BYTE* pHashData, DWORD cbHashData)
{
	HCRYPTHASH hHash = 0;
	HCRYPTPROV hProv = 0;

	if (CryptAcquireContext(&hProv,
		NULL,
		NULL,
		PROV_RSA_AES,
		CRYPT_VERIFYCONTEXT) == FALSE)
	{
		return GetLastError_s();
	}
	
	LSTATUS lStatus = ERROR_SUCCESS;

	if (CryptCreateHash(hProv, Algid, 0, 0, &hHash) == FALSE)
	{
		lStatus = GetLastError_s();
	}
	else
	{
		CHFile hFile = CreateFile(FilePath,
			GENERIC_READ,
			FILE_SHARE_READ,
			NULL,
			OPEN_EXISTING,
			FILE_FLAG_BACKUP_SEMANTICS,
			NULL);

		if (hFile.IsInvalid())
		{
			lStatus = GetLastError_s();
		}
		else
		{
			BYTE Buffer[1024];
			DWORD cbRead;
			lStatus = ERROR_INVALID_DATA;

			while (ReadFile(hFile, Buffer, sizeof(Buffer), &cbRead, NULL))
			{
				if (0 == cbRead)
				{
					lStatus = ERROR_SUCCESS;
					break;
				}

				if (CryptHashData(hHash, Buffer, cbRead, 0) == FALSE)
				{
					lStatus = GetLastError_s();
					break;
				}
			}


			if (lStatus == ERROR_SUCCESS)
			{
				cbRead = cbHashData;
				if (CryptGetHashParam(hHash, HP_HASHVAL, pHashData, &cbRead, 0) == FALSE)
					lStatus = GetLastError_s();
			}
		}

		CryptDestroyHash(hHash);
	}

	CryptReleaseContext(hProv, 0);
	return lStatus;
}

LSTATUS GetHashByData(LPCBYTE pData, DWORD cbData, ALG_ID Algid, BYTE* pHashData, DWORD cbHashData)
{
	HCRYPTHASH hHash = 0;
	HCRYPTPROV hProv = 0;

	if (CryptAcquireContext(&hProv,
		NULL,
		NULL,
		PROV_RSA_AES,
		CRYPT_VERIFYCONTEXT) == FALSE)
	{
		return GetLastError_s();
	}
	LSTATUS lStatus = ERROR_SUCCESS;

	if (CryptCreateHash(hProv, Algid, 0, 0, &hHash) == FALSE)
	{
		lStatus = GetLastError_s();
	}
	else
	{
		if (CryptHashData(hHash, pData, cbData, 0) == FALSE)
		{
			lStatus = GetLastError_s();
		}

		if (lStatus == ERROR_SUCCESS)
		{
			cbData = cbHashData;
			if (CryptGetHashParam(hHash, HP_HASHVAL, pHashData, &cbData, 0) == FALSE)
				lStatus = GetLastError_s();
		}


		CryptDestroyHash(hHash);
	}

	CryptReleaseContext(hProv, 0);
	return lStatus;
}

LSTATUS GetMd5ByFilePath(LPCWSTR FilePath, BYTE FileMd5[16])
{
	return GetHashByFilePath(FilePath, CALG_MD5, FileMd5, sizeof(BYTE) * 16);
}

LSTATUS GetMd5ByData(LPCBYTE pData, DWORD cbData, BYTE FileMd5[16])
{
	return GetHashByData(pData, cbData, CALG_MD5, FileMd5, sizeof(BYTE) * 16);
}

LSTATUS GetSha1ByFilePath(LPCWSTR FilePath, BYTE FileSha1[20])
{
	return GetHashByFilePath(FilePath, CALG_SHA1, FileSha1, sizeof(BYTE) * 20);
}

//无视权限移动文件或者文件夹（创建硬链接等）
//DWORD MoveFileEx2(LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, DWORD dwFlags)
//{
//	HANDLE hFile = CreateFile(lpExistingFileName, SYNCHRONIZE | DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);
//
//	if (hFile == INVALID_HANDLE_VALUE)
//	{
//		return GetLastError();
//	}
//
//	IO_STATUS_BLOCK IoStatusBlock;
//	HRESULT hr;
//
//	
//	UNICODE_STRING usFilePath = {};
//
//	if (!RtlDosPathNameToNtPathName_U(lpNewFileName, &usFilePath, NULL, NULL))
//	{
//		hr= ERROR_PATH_NOT_FOUND;
//	}
//	else
//	{
//		auto cbData = sizeof(FILE_RENAME_INFORMATION) + usFilePath.MaximumLength;
//
//		FILE_RENAME_INFORMATION* pInfo = (FILE_RENAME_INFORMATION*)new char[cbData];
//
//		pInfo->RootDirectory = NULL;
//
//
//		pInfo->ReplaceIfExists = dwFlags&MOVEFILE_REPLACE_EXISTING;
//
//		pInfo->FileNameLength = usFilePath.Length;
//
//		memcpy(pInfo->FileName, usFilePath.Buffer, usFilePath.MaximumLength);
//		RtlFreeUnicodeString(&usFilePath);
//
//		hr = NtSetInformationFile(hFile, &IoStatusBlock, pInfo, cbData, dwFlags&MOVEFILE_CREATE_HARDLINK ? FileLinkInformation : FileRenameInformation);
//		
//		if (hr)
//			hr = RtlNtStatusToDosError(hr);
//
//		delete[](char*)pInfo;
//	}
//	
//	CloseHandle(hFile);
//
//	return hr;
//}






void PathCat(CString& Path, LPCWSTR Append)
{
	if (Path.GetLength() == 0 || Path[Path.GetLength() - 1] != L'\\')
	{
		Path += L'\\';
	}

	if (Append)
	{
		if (*Append == L'\\')
			Append++;

		Path += Append;
	}
}


CString PathCat(LPCWSTR Path, LPCWSTR Append)
{
	CString _Path(Path);

	PathCat(_Path, Append);

	return _Path;
}






//void GetCtlCode(DWORD Code, DWORD& DeviceType, DWORD& Function, DWORD& Method, DWORD& Access)
//{
//	//
//	DeviceType = Code >> 16;
//	Access = (Code & 0xFFFF) >> 14;
//	Function = (Code & 0x3FFF) >> 2;
//	Method = Code & 0x3;
//}


LSTATUS CreateFileByData(LPCWSTR FilePath, LPCWSTR lpName, LPCWSTR lpType, HMODULE hModule)
{
	HRSRC hrsc = FindResource(hModule, lpName, lpType);

	if (!hrsc)
		return GetLastError_s();

	HGLOBAL resGlobal = LoadResource(hModule, hrsc);

	if (!resGlobal)
		return GetLastError_s();


	return CreateFileByData(FilePath, (void*)resGlobal, SizeofResource(hModule, hrsc));
}

LSTATUS CreateFileByData(LPCWSTR FilePath, const void* Data, DWORD ccbData)
{
	if (Data == NULL)
		return ERROR_DATABASE_FULL;

	DWORD FileAttr = GetFileAttributes(FilePath);

	if (FileAttr != INVALID_FILE_ATTRIBUTES && (FileAttr&FILE_ATTRIBUTE_READONLY))
	{
		SetFileAttributes(FilePath, FileAttr&(-1 ^ FILE_ATTRIBUTE_READONLY));
	}

	LSTATUS lStatus = ERROR_SUCCESS;

	auto thFile = CreateFile(FilePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL| FILE_FLAG_BACKUP_SEMANTICS, 0);

	if (thFile != INVALID_HANDLE_VALUE)
	{
		if (!WriteFile(thFile, Data, ccbData, &ccbData, NULL))
		{
			lStatus = GetLastError_s();
		}

		CloseHandle(thFile);
	}
	else
	{
		lStatus = GetLastError_s();
	}

	if (FileAttr != INVALID_FILE_ATTRIBUTES)
	{
		SetFileAttributes(FilePath, FileAttr);
	}


	return lStatus;
}
//#include <unzip.h>

LSTATUS CreateFileByZipData(LPCWSTR FilePath, const void* Data, DWORD ccbData)
{
	auto hZip = OpenZip((void*)Data, ccbData, (char*)NULL);

	//FreeResource(hGlobal);

	if (hZip == NULL)
	{
		return ERROR_BAD_FORMAT;
	}

	LSTATUS lStatus = ERROR_BAD_FORMAT;
	CStringA Buffer;

	ZIPENTRY ze;

	if (GetZipItem(hZip, 0, &ze))
		goto End;

	if (UnzipItem(hZip, 0, Buffer.GetBuffer(ze.unc_size), ze.unc_size))
	{
		goto End;
	}

	lStatus = CreateFileByData(FilePath, Buffer.GetBuffer(), ze.unc_size);

End:
	CloseZip(hZip);
	return lStatus;
}

//为一个路径创建所有父
LSTATUS CreateRoot(LPCWSTR FilePath)
{
	CStringW Buffer = FilePath;

	if (Buffer.GetLength() == 0)
		return ERROR_INVALID_PARAMETER;

	if (Buffer[Buffer.GetLength() - 1] != L'\\')
	{
		Buffer.ReleaseBufferSetLength(Buffer.ReverseFind(L'\\') + 1);
	}



	for (auto Path = StrChrW(PathSkipRoot(Buffer), L'\\'); Path; Path = StrChrW(Path + 1, L'\\'))
	{
		*Path = NULL;

		if (!CreateDirectoryW(Buffer, NULL))
		{
			auto lStatus = GetLastError_s();

			if(lStatus != ERROR_ALREADY_EXISTS)
				return lStatus;
		}

		*Path = L'\\';
	}

	return ERROR_SUCCESS;
}

#include <ntddvol.h>


HANDLE OpenDriver(LPCWSTR DriverPath, DWORD dwDesiredAccess)
{
	CString _RootPath = *DriverPath == L'\\' ? L"" : L"\\??\\";;

	_RootPath += DriverPath;

	if (_RootPath[_RootPath.GetLength() - 1] == L'\\')
		_RootPath.ReleaseBufferSetLength(_RootPath.GetLength() - 1);

	return CreateFileW(_RootPath, dwDesiredAccess, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);
}

LSTATUS GetDriverLayout(HANDLE hDevice, CStringA& Buffer)
{
	DWORD ccbLauout = 0;

	Buffer.Empty();

	Buffer.GetBuffer(sizeof(DRIVE_LAYOUT_INFORMATION_EX) + sizeof(PARTITION_INFORMATION_EX) * 8);

	while (!DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_LAYOUT_EX, NULL, 0, Buffer.GetBuffer(), Buffer.GetAllocLength(), &ccbLauout, NULL))
	{
		auto lStatus = GetLastError();
		if (lStatus == ERROR_INSUFFICIENT_BUFFER)
		{
			Buffer.GetBuffer(Buffer.GetAllocLength() + sizeof(PARTITION_INFORMATION_EX) * 8);
		}
		else if(lStatus!=ERROR_SUCCESS)
		{
			return lStatus;
		}
		else
		{
			return ERROR_FUNCTION_FAILED;
		}
	}

	Buffer.ReleaseBufferSetLength(ccbLauout);

	return ERROR_SUCCESS;
}

LSTATUS GetDriverLayout(LPCWSTR DriverPath, CStringA& Buffer)
{
	CHFile hDevice = OpenDriver(DriverPath);

	if (hDevice.IsInvalid())
		return GetLastError_s();

	return ::GetDriverLayout(hDevice, Buffer);
}

int GetPartitionDisk(HANDLE hDevice)
{
	//扫描硬盘下标
	VOLUME_LOGICAL_OFFSET LogicalOffset = {};
	VOLUME_PHYSICAL_OFFSETS PhysicalOffsets = {};
	DWORD cbRet = 0;

	if (!DeviceIoControl(hDevice, IOCTL_VOLUME_LOGICAL_TO_PHYSICAL, &LogicalOffset, sizeof(LogicalOffset), &PhysicalOffsets, sizeof(PhysicalOffsets), &cbRet, NULL))
	{
		return -1;
	}

	return PhysicalOffsets.PhysicalOffset->DiskNumber;
}

LSTATUS GetPartitionInfomation(HANDLE hDevice, PARTITION_INFORMATION_EX& PartitionInfo)
{
	DWORD cbPartitionInfo = 0;

	return DeviceIoControl(hDevice, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &PartitionInfo, sizeof(PARTITION_INFORMATION_EX), &cbPartitionInfo, NULL)
		? ERROR_SUCCESS : GetLastError_s();
}

int GetPartition(HANDLE hDevice)
{
	PARTITION_INFORMATION_EX PartitionInfo;

	if (GetPartitionInfomation(hDevice, PartitionInfo)!= ERROR_SUCCESS)
		return -1;

	return PartitionInfo.PartitionNumber;
}



LSTATUS GetVhdVolumeFilePath(HANDLE hDevice, CString& VHDFilePath)
{
	DWORD InputBuffer = 1;

	DWORD cbRet = 0;

	wchar_t szVHDFilePath[512];

	if (!DeviceIoControl(hDevice, 0x2D5928, &InputBuffer, sizeof(DWORD), szVHDFilePath, sizeof(szVHDFilePath), &cbRet, NULL))
	{
		return GetLastError_s();
	}

	if (StrCmpN(szVHDFilePath, L"\\??\\", StaticStrLen(L"\\??\\")) == 0)
	{
		VHDFilePath = szVHDFilePath + 4;
	}
	else
	{
		VHDFilePath = szVHDFilePath;
	}
	

	return ERROR_SUCCESS;
}

LSTATUS GetVhdVolumeFilePath(LPCWSTR hDevicePath, CString& VHDFilePath)
{
	CHFile hDriver = OpenDriver(hDevicePath);

	if (hDriver.IsInvalid())
		return GetLastError_s();

	return GetVhdVolumeFilePath(hDriver, VHDFilePath);
}

LSTATUS __fastcall GetDevicePath(const GUID& Guid, std::vector<CString>& pszDevicePath)
{
	pszDevicePath.clear();

	auto hDevInfoSet = SetupDiGetClassDevs(

		&Guid,      // class GUID 

		NULL,        // Enumerator

		NULL,        // hwndParent

		DIGCF_PRESENT | DIGCF_DEVICEINTERFACE    // present devices

		);

	if (hDevInfoSet == INVALID_HANDLE_VALUE)
	{

		return GetLastError_s();
	}


	byte DETAIL_DATA_Buffer[1024];

	auto& Detail = *(SP_DEVICE_INTERFACE_DETAIL_DATA*)DETAIL_DATA_Buffer;

	Detail.cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);


	SP_DEVICE_INTERFACE_DATA ifdata;
	ifdata.cbSize = sizeof(ifdata);

	for (DWORD i=0;SetupDiEnumDeviceInterfaces(hDevInfoSet,NULL,&Guid,i,&ifdata );++i)
	{
		if(SetupDiGetDeviceInterfaceDetail(

			hDevInfoSet,    // DeviceInfoSet

			&ifdata,        // DeviceInterfaceData

			&Detail,        // DeviceInterfaceDetailData

			sizeof(DETAIL_DATA_Buffer),    // DeviceInterfaceDetailDataSize

			NULL,           // RequiredSize

			NULL          // DeviceInfoData

			))
		{
			pszDevicePath.push_back(Detail.DevicePath);
		}
	}

	SetupDiDestroyDeviceInfoList(hDevInfoSet);

	return ERROR_SUCCESS;
}

LSTATUS GetDiskCount(std::vector<CString>& pszDevicePath)
{
	//vector<CString> pszDevicePath;

	return GetDevicePath(GUID_DEVINTERFACE_DISK, pszDevicePath);
}


//#include <Dbghelp.h>
//#pragma comment(lib,"Dbghelp.lib")
//#pragma comment(lib,"IMAGEHLP.lib")

byte* IsProcExistsInternal(byte* pBase,byte* pEnd, PIMAGE_NT_HEADERS pNtHeaders, DWORD VirtualAddress, LPCSTR ProcName)
{
	auto pExportTable = (PIMAGE_EXPORT_DIRECTORY)RtlImageRvaToVa((PIMAGE_NT_HEADERS)pNtHeaders, pBase, VirtualAddress, NULL);


	//auto pExportTable = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)pBase +VirtualAddress);
	//IMAGE_OPTIONAL_HEADER * Opthdr = (PIMAGE_OPTIONAL_HEADER)((byte*)pBase + DosHeader->e_lfanew + 24);

	if (pExportTable == NULL)
		return NULL;

	if ((byte*)pExportTable+sizeof(IMAGE_EXPORT_DIRECTORY) >= pEnd)
	{
		return NULL;
	}


	auto pNames = (PDWORD)RtlImageRvaToVa(
		(PIMAGE_NT_HEADERS)pNtHeaders, pBase,
		pExportTable->AddressOfNames,
		NULL);
	//PULONG pNames = (ULONG*)((BYTE*)pBase + pExportTable->AddressOfNames);

	if (pNames == NULL)
		return NULL;

	//检查长度
	if ((byte*)pNames + pExportTable->NumberOfNames *sizeof(*pNames) >= pEnd)
	{
		return NULL;
	}

	//IMAGE_DOS_HEADER * DosHeader = (PIMAGE_DOS_HEADER)GetModuleHandle(L"ntdll.dll");
	//IMAGE_OPTIONAL_HEADER * Opthdr = (PIMAGE_OPTIONAL_HEADER)((byte*)DosHeader + DosHeader->e_lfanew + 24);
	//PIMAGE_EXPORT_DIRECTORY Export = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)DosHeader + Opthdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
	//PULONG pAddressOfFunctions = (ULONG*)((BYTE*)DosHeader + Export->AddressOfFunctions);
	//PULONG pAddressOfNames = (ULONG*)((BYTE*)DosHeader + Export->AddressOfNames);
	//PUSHORT  pAddressOfNameOrdinals = (USHORT*)((BYTE*)DosHeader + Export->AddressOfNameOrdinals);

	//DWORD Protect;
	//for (int i = 0; i <Export->NumberOfNames; i++)
	//{
	//	auto index = pAddressOfNameOrdinals[i];
	//	char *pFuncName = (char*)((BYTE*)DosHeader + pAddressOfNames[i]);
	//	if (StrCmpIA((char*)pFuncName, "NtCreateFile") == 0)
	//	{

	//		pAddressOfFunctions[index] = (DWORD)((byte*)MyNtCreateFile - (byte*)DosHeader);

	//		//addr = pAddressOfFunctions[index];
	//		break;
	//	}
	//}

	auto cbProcName = strlen(ProcName)+1;

	for (int i = 0; i != pExportTable->NumberOfNames; i++)
	{
		LPCSTR szFuncName = (LPCSTR)RtlImageRvaToVa(
			(PIMAGE_NT_HEADERS)pNtHeaders, pBase,
			pNames[i],
			NULL);

		if (szFuncName == NULL)
			continue;

		//检查字符串长度
		if ((byte*)szFuncName + cbProcName >= pEnd)
		{
			return NULL;
		}

		//auto szFuncName = (LPCSTR)((BYTE*)pBase + pNames[i]);

		if (memcmp(ProcName, szFuncName, cbProcName) == 0)
		{
			//已经匹配。开始搜索下标

			auto pNameOrdinals = (PWORD)RtlImageRvaToVa(
				(PIMAGE_NT_HEADERS)pNtHeaders, pBase,
				pExportTable->AddressOfNameOrdinals,
				NULL);

			if (!pNameOrdinals)
				return NULL;

			if ((byte*)pNameOrdinals + sizeof(*pNameOrdinals)*pExportTable->NumberOfNames >= pEnd)
			{
				return NULL;
			}

			//
			auto pFunctions = (PDWORD)RtlImageRvaToVa(
				(PIMAGE_NT_HEADERS)pNtHeaders, pBase,
				pExportTable->AddressOfFunctions,
				NULL);

			pFunctions += pNameOrdinals[i];

			if ((byte*)pFunctions + sizeof(*pFunctions) >= pEnd)
			{
				return NULL;
			}

			return (byte*)RtlImageRvaToVa(pNtHeaders, pBase, pFunctions[pNameOrdinals[i]], NULL);
		}
	}

	return NULL;
}

byte* IsProcExists(byte* pBase,byte* pEnd, LPCSTR ProcName)
{
	if (pBase == NULL)
		return NULL;

	auto pNtHeader = RtlImageNtHeader(pBase);

	if (pNtHeader == NULL)
		return NULL;

	if ((byte*)pNtHeader + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) >= pEnd )
	{
		//NtHeader越界！
		return NULL;
	}

	switch (pNtHeader->FileHeader.Machine)
	{
	case IMAGE_FILE_MACHINE_I386:
		return IsProcExistsInternal(pBase, pEnd, pNtHeader, ((PIMAGE_NT_HEADERS32)pNtHeader)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress, ProcName);
		break;
	case IMAGE_FILE_MACHINE_AMD64:
	case IMAGE_FILE_MACHINE_IA64:
		return IsProcExistsInternal(pBase, pEnd, pNtHeader, ((PIMAGE_NT_HEADERS64)pNtHeader)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress, ProcName);
		break;
	default:
		return NULL;
		break;
	}
}

//bool IsProcExists(HMODULE hModule, LPCSTR ProcName)
//{
//	return IsProcExists((byte*)((SIZE_T)hModule&(-1^0x3)), ProcName);
//}

bool IsProcExists(HANDLE hFile, LPCSTR ProcName)
{
	CHFile hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

	auto pBase = (byte*)MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);

	if (!pBase)
		return false;

	auto ret = IsProcExists(pBase, pBase+GetFileSize(hFile,NULL), "DllGetClassObject");

	UnmapViewOfFile(pBase);

	return ret;
}

DWORD GetFileArchitecture(LPCWSTR FilePath)
{
	CHFile hFile = CreateFile(FilePath, GENERIC_READ, FILE_SHARE_DELETE | FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);

	if (hFile.IsInvalid())
		return PROCESSOR_ARCHITECTURE_UNKNOWN;

	CHFile hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

	auto pBase = (byte*)MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);

	if (pBase == NULL)
		return PROCESSOR_ARCHITECTURE_UNKNOWN;

	WORD Machine = PROCESSOR_ARCHITECTURE_UNKNOWN;


	auto pNtHeader = RtlImageNtHeader(pBase);

	if (pNtHeader)
	{
		Machine = pNtHeader->FileHeader.Machine;
	}


	UnmapViewOfFile(pBase);
	//return Machine;


	switch (Machine)
	{
	case IMAGE_FILE_MACHINE_I386:
		return PROCESSOR_ARCHITECTURE_INTEL;
		break;
	case IMAGE_FILE_MACHINE_AMD64:
		return PROCESSOR_ARCHITECTURE_AMD64;
	case IMAGE_FILE_MACHINE_IA64:
		return PROCESSOR_ARCHITECTURE_IA64;
		break;
	case IMAGE_FILE_MACHINE_ARMNT:
		return PROCESSOR_ARCHITECTURE_ARM;
		break;
	case /*IMAGE_FILE_MACHINE_ARM64*/0xAA64:
		return /*PROCESSOR_ARCHITECTURE_ARM64*/12;
		break;
	default:
		return PROCESSOR_ARCHITECTURE_UNKNOWN;
		break;
	}
}

NTSTATUS CompressBuffer(const void* Src, DWORD cbSrc, void* Dst, DWORD* pcbDst)
{
	ULONG CompressBufferWorkSpaceSize = 0;
	ULONG CompressFragmentWorkSpaceSize = 0;

	auto Status = RtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_LZNT1, &CompressBufferWorkSpaceSize, &CompressFragmentWorkSpaceSize);

	if (Status!= STATUS_SUCCESS)
		return Status;

	CStringA WorkSpaceBuffer;

	return RtlCompressBuffer(COMPRESSION_FORMAT_LZNT1, (PUCHAR)Src, cbSrc, (PUCHAR)Dst, pcbDst ? *pcbDst : 0, 512, pcbDst, WorkSpaceBuffer.GetBuffer(CompressBufferWorkSpaceSize));
}

NTSTATUS DecompressBuffer(const void* Src, DWORD cbSrc, void* Dst, DWORD* pcbDst)
{
	return RtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1, (PUCHAR)Dst, *pcbDst, (PUCHAR)Src, cbSrc, pcbDst);
}


#include <fltUser.h>

#pragma comment(lib,"FltLib.lib")

HRESULT NtPath2DosPath(LPCWSTR NtPath, CString& DosPath)
{
	if (StrCmpN(NtPath, L"\\\\?\\", StaticStrLen(L"\\\\?\\")))
	{
		return NtPath2DosPath(CString(L"\\\\?\\GLOBALROOT") + NtPath, DosPath);
	}

	if (!GetVolumePathName(NtPath, DosPath.GetBuffer(MAX_PATH), MAX_PATH))
		return HresultFromBool();

	DosPath.ReleaseBuffer();

	NtPath += DosPath.GetLength() - 1;

	auto hr = FilterGetDosName(DosPath, DosPath.GetBuffer(MAX_PATH), MAX_PATH);
	if (hr!=S_OK)
		return hr;

	DosPath.ReleaseBuffer();

	DosPath += NtPath;

	return S_OK;
}


BOOL LoadString_s(LPCWSTR FilePath, int Index, CString& String)
{
	CHModule pHmodule = LoadLibraryExW(FilePath, NULL, LOAD_LIBRARY_AS_DATAFILE);

	if (pHmodule == INVALID_HANDLE_VALUE)
		return FALSE;

	return String.LoadStringW(pHmodule, Index);
}

BOOL LoadString_s(LPCWSTR FilePath, int Index, LPBSTR pString)
{
	CHModule pHmodule = LoadLibraryExW(FilePath, NULL, LOAD_LIBRARY_AS_DATAFILE);

	if (pHmodule == INVALID_HANDLE_VALUE)
		return FALSE;


	return CComBSTR::LoadStringResource(pHmodule, Index, *pString);
}


DWORD MultiStrLen(LPCWSTR String)
{
	if (String == NULL)
		return 0;

	DWORD Len = 0;

	auto Str = String;

	for (; *Str; Str = StrSpet(Str));

	return Str - String + 1;
}
PVOID64 GetProcAddressExiInternal(HANDLE hProc, HMODULE hModule, LPCSTR lpProcName, DWORD ExportVirtualAddress)
{
	PVOID64 pAddress = NULL;

	IMAGE_EXPORT_DIRECTORY ExpDir;
	//SIZE_T ExportVirtualAddress = NtHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	CHAR ProcName[MAX_PATH];

	auto chProcName = strlen(lpProcName) + 1;

	//读输出表
	if (ExportVirtualAddress && !NtReadVirtualMemory(hProc, (PVOID)((UINT64)hModule + ExportVirtualAddress), &ExpDir, sizeof(ExpDir), NULL))
	{
		if (ExpDir.NumberOfFunctions)
		{
			//x64待定:地址数组存放RVA的数据类型是4字节还是8字节???
			DWORD *pProcAddressTable = new DWORD[ExpDir.NumberOfFunctions];

			//读函数地址表
			if (!NtReadVirtualMemory(hProc, (PVOID)((SIZE_T)hModule + ExpDir.AddressOfFunctions), pProcAddressTable, ExpDir.NumberOfFunctions * sizeof(DWORD), NULL))
			{
				//x64待定:名称数组存放RVA的数据类型是4字节还是8字节???
				DWORD *pProcNamesTable = new DWORD[ExpDir.NumberOfNames];

				//读函数名称表
				if (!NtReadVirtualMemory(hProc, (PVOID)((SIZE_T)hModule + ExpDir.AddressOfNames), pProcNamesTable, ExpDir.NumberOfNames * sizeof(DWORD), NULL))
				{

					//遍历函数名称
					for (DWORD i = 0; i < ExpDir.NumberOfNames; i++)
					{
						if (!NtReadVirtualMemory(hProc, (PVOID)((SIZE_T)hModule + pProcNamesTable[i]), ProcName, chProcName, NULL))
						{
							if (memcmp(lpProcName, ProcName, chProcName) == 0)
							{
								//x64待定:函数在地址数组索引的数据类型是2字节还是???
								WORD NameOrdinal;

								//获取函数在地址表的索引
								if (!NtReadVirtualMemory(hProc, (PVOID)((SIZE_T)hModule + ExpDir.AddressOfNameOrdinals + sizeof(NameOrdinal) * i), &NameOrdinal, sizeof(NameOrdinal), NULL))
								{
									pAddress = (PVOID64)((SIZE_T)hModule + pProcAddressTable[NameOrdinal]);
								}
								break;//for
							}
						}
					}
				}
				delete[] pProcNamesTable;
			}

			delete[] pProcAddressTable;
		}
	}


	return pAddress;
}

PVOID64 GetProcAddressEx(HANDLE hProc, HMODULE hModule, LPCSTR lpProcName)
{
	IMAGE_DOS_HEADER DosHeader;
	//SIZE_T ProcNameLength = lstrlenA(lpProcName) + sizeof(CHAR);//'\0'

	//读DOS头
	if (!NtReadVirtualMemory(hProc, hModule, &DosHeader, sizeof(DosHeader), NULL))
	{
#ifdef _AMD64_
		BOOL Wow64Process = FALSE;

		IsWow64Process(hProc, &Wow64Process);

		if (Wow64Process)
		{
			IMAGE_NT_HEADERS32 NtHeader;

			//读NT头
			if (!NtReadVirtualMemory(hProc, (PVOID)((SIZE_T)hModule + DosHeader.e_lfanew), &NtHeader, sizeof(NtHeader), NULL))
			{
				return GetProcAddressExiInternal(hProc, hModule, lpProcName, NtHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
			}
		}
		else
		{
#endif
			IMAGE_NT_HEADERS NtHeader;

			//读NT头
			if (!ReadProcessMemory(hProc, (PVOID)((SIZE_T)hModule + DosHeader.e_lfanew), &NtHeader, sizeof(NtHeader), NULL))
			{
				return GetProcAddressExiInternal(hProc, hModule, lpProcName, NtHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
			}
#ifdef _AMD64_
		}
#endif
	}
	return NULL;
}

LSTATUS GetLongPathName_s(
	LPCWSTR   lpszShortPath, 
	CStringW& lpszLongPath
	)
{
	if (StrCmpNW(L"\\\\?\\", lpszShortPath, StaticStrLen(L"\\\\?\\")) == 0)
	{
		lpszShortPath += StaticStrLen(L"\\\\?\\");
	}
	
	CStringW Buffer;

	DWORD cBufferUsed = MAX_PATH;
	for (;;)
	{
		auto pBuffer = Buffer.GetBuffer(cBufferUsed);
		auto cBuffer = Buffer.GetAllocLength();

		cBufferUsed = GetLongPathNameW(lpszShortPath, pBuffer, cBuffer);

		if (cBufferUsed == 0)
		{
			return GetLastError_s();
		}
		else if (cBufferUsed <= cBuffer)
		{
			Buffer.ReleaseBufferSetLength(cBufferUsed);

			lpszLongPath = Buffer;

			return ERROR_SUCCESS;
		}
		else
		{
			//缓冲区不足
		}
	}


}

LSTATUS __fastcall ExpandEnvironmentStrings_s(
    LPCWSTR   lpszShortPath,
    CStringW& lpszLongPath
    )
{
	CStringW Buffer;

	DWORD cBufferUsed = MAX_PATH;

	for (;;)
	{
		auto pBuffer = Buffer.GetBuffer(cBufferUsed);

		auto cBuffer = Buffer.GetAllocLength();

		cBufferUsed = ExpandEnvironmentStringsW(lpszShortPath, pBuffer, cBuffer);

		if (cBufferUsed == 0)
		{
			return GetLastError_s();
		}
		else if (cBufferUsed <= cBuffer)
		{
			Buffer.ReleaseBufferSetLength(cBufferUsed - 1);
			lpszLongPath = Buffer;

			return ERROR_SUCCESS;
		}
		else
		{
			//缓冲区不足
		}
	}
}

LSTATUS __fastcall GetVolumePathName_s(
	LPCWSTR   lpszFileName,
	CStringW& szLongPath
	)
{
	CStringW Temp;

	if (!GetVolumePathNameW(lpszFileName, Temp.GetBuffer(MAX_PATH), MAX_PATH))
	{
		return GetLastError_s();
	}

	Temp.ReleaseBuffer();

	szLongPath = Temp;

	return ERROR_SUCCESS;
}

byte Char2Hex(wchar_t ch)
{
	if (ch >= L'0'&&ch <= L'9')
	{
		return ch - L'0';
	}
	else if (ch >= L'A'&&ch <= L'F')
	{
		return ch - L'A' + 10;
	}
	else if (ch >= L'a'&&ch <= L'f')
	{
		return ch - L'a' + 10;
	}
	else
	{
		//意外的字符串！
		assert(1);

		return 0xCC;
	}
}

HRESULT HresultFromBool(BOOL bSuccess)
{
	if (bSuccess)
		return S_OK;
	else
		return HresultFromBoolFalse();
}

HRESULT HresultFromBoolFalse()
{
	auto lStatus = GetLastError();

	if (lStatus)
	{
		if (lStatus & 0xFFFF0000)
			return lStatus;

		return (lStatus | (FACILITY_WIN32 << 16) | 0x80000000);
	}
	else
	{
		//错误代码为0 转换为非指定的错误
		return E_FAIL;
	}
}

LSTATUS GetLastError_s(BOOL bSuccess)
{
	if (bSuccess)
		return ERROR_SUCCESS;
	else
		return GetLastErrorFromBoolFalse();
}

LSTATUS GetLastErrorFromBoolFalse()
{
	auto lStatus = GetLastError();

	return lStatus ? lStatus : ERROR_FUNCTION_FAILED;
}

int __fastcall StrLen(_In_opt_z_ LPCSTR psz)
{
	// returns length in bytes
	return (psz != NULL) ? (int)strlen(psz) : 0;
}

int __fastcall StrLen(_In_opt_z_ LPCWSTR psz)
{
	// returns length in wchar_ts
	return (psz != NULL) ? (int)wcslen(psz) : 0;
}

BOOL IsCompatibilityMode()
{
	OSVERSIONINFOW VersionInformation = { sizeof(VersionInformation) };

	#pragma warning(suppress:28159)
	if (!GetVersionExW(&VersionInformation))
	{
		return -1;
	}

	auto pPeb = ((TEB*)NtCurrentTeb())->ProcessEnvironmentBlock;

	return pPeb->OSMajorVersion != VersionInformation.dwMajorVersion
		|| pPeb->OSMinorVersion != VersionInformation.dwMinorVersion
		|| pPeb->OSBuildNumber != VersionInformation.dwBuildNumber;
}

DWORD DirectGetOsMinVersion()
{
	auto pPeb = ((TEB*)NtCurrentTeb())->ProcessEnvironmentBlock;

	return MakeMiniVersion(pPeb->OSMajorVersion, pPeb->OSMinorVersion);
}

UINT64 DirectGetOsVersion()
{
	auto pPeb = ((TEB*)NtCurrentTeb())->ProcessEnvironmentBlock;

	return MakeVersion(pPeb->OSMajorVersion, pPeb->OSMinorVersion, pPeb->OSBuildNumber, 0);
}

LPCWSTR __cdecl FormatLongString(LPCWSTR _Format, ...)
{
	LPCWSTR pBuffer;
	va_list _ArgList;
	__crt_va_start(_ArgList, _Format);

	auto cBuffer = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING, _Format, 0, 0, (LPWSTR)&pBuffer, 0, &_ArgList);

	__crt_va_end(_ArgList);

	return cBuffer ? pBuffer : nullptr;
}


LSTATUS __fastcall GetModuleFileName_s(
	_In_opt_ HMODULE   hModule,
	_Out_    CStringW& szModulePath
	)
{
	auto AllocLength = max(szModulePath.GetAllocLength(), MAX_PATH);

	for (;;)
	{
		auto szPath = szModulePath.GetBuffer(AllocLength);

		auto Length = GetModuleFileNameW(hModule, szPath, AllocLength);

		if (Length == 0)
		{
			return GetLastError_s();
		}
		else if (Length < AllocLength)
		{
			//获取完成
			szModulePath.ReleaseBufferSetLength(Length);

			return ERROR_SUCCESS;
		}
		else
		{
			//缓冲区不足，加大缓冲区继续
			AllocLength = Length + 1;
		}
	}
}

LSTATUS __fastcall ModuleAddRef(
	_In_ HMODULE hModule
	)
{
	HMODULE hModuleTmp;

	return GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, (LPCWSTR)hModule, &hModuleTmp) ? ERROR_SUCCESS : GetLastError_s();
}

#pragma warning(pop)
